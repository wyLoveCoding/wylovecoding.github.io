<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Java多线程学习总结 | 我爱刷题</title>
<meta name="description" content="心中无女人，编码自然神(●&#39;◡&#39;●)">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="https://wylovecoding.github.io/favicon.ico?v=1617756339348">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://unpkg.com/papercss@1.6.1/dist/paper.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://wylovecoding.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


  </head>
  <body>
  
    <nav class="navbar border fixed split-nav">
  <div class="nav-brand">
    <h3><a href="https://wylovecoding.github.io">我爱刷题</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
      <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
        
          <li>
            
              <a href="/" class="menu">
                首页
              </a>
            
          </li>
        
          <li>
            
              <a href="/archives" class="menu">
                归档
              </a>
            
          </li>
        
          <li>
            
              <a href="/tags" class="menu">
                标签
              </a>
            
          </li>
        
          <li>
            
              <a href="/post/about" class="menu">
                关于
              </a>
            
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div id="top" class="row site">
      <div class="sm-12 md-8 col">
        <div class="paper">
          <article class="article">
            <h1>Java多线程学习总结</h1>
            <p class="article-meta">
              2021-04-06
              
            </p>
            
            <div class="post-content">
              <h2 id="11-进程与线程">1.1 进程与线程</h2>
<h3 id="111-进程">1.1.1 进程</h3>
<blockquote>
<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即 是一个进程从创建、运行到消亡的过程。在Java中，当我们启动main函数，其实就是启动了一个JVM的进程，而main函数所在的线程就是这个进程中的一个线程，也称主线程。</p>
</blockquote>
<h3 id="112-线程">1.1.2 线程</h3>
<blockquote>
<p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源。但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。所以系统在产生一个线程，或者是在各个线程之间切换工作时，负担要比进程小的多，也正因如此，线程也被称作轻量级进程。</p>
</blockquote>
<h3 id="113-进程与线程之间的关系-区别及优缺点">1.1.3 进程与线程之间的关系、区别及优缺点</h3>
<p>从JVM角度讲进程和线程之间的关系<br>
下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。<br>
<img src="https://wylovecoding.github.io/post-images/1617710272956.png" alt="" loading="lazy"><br>
从上图可以看出：一个进程可以有多个线程，多个线程共享进程的堆和方法区，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</p>
<blockquote>
<p><strong>总结</strong>：线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而线程则不一定，因为同一进程中的线程很有可能会相互影响。线程执行开销小，但不利于资源的管理和保护，进程则恰恰相反。</p>
</blockquote>
<h2 id="12-并发与并行">1.2 并发与并行</h2>
<ul>
<li><strong>并发</strong>：同一时间段，多个任务都在执行（单位时间内不一定同时执行）</li>
<li><strong>并行</strong>：单位时间内，多个任务同时执行。</li>
</ul>
<h2 id="13-为什么要使用多线程">1.3 为什么要使用多线程</h2>
<ul>
<li><strong>从计算机底层来讲</strong>：线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核CPU时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来讲</strong>：现在的系统动不动就要求百万甚至千万级的并发量，而多线程并发编程正式开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<h2 id="14-使用多线程可能带来什么问题">1.4 使用多线程可能带来什么问题</h2>
<p>并发编程的目的就是为了能够提高程序的执行效率，但是也可能会遇到很多问题，诸如内存泄漏、死锁、上下文切换等。</p>
<h2 id="15-线程的生命周期和状态">1.5 线程的生命周期和状态</h2>
<p><img src="https://wylovecoding.github.io/post-images/1617712547983.png" alt="" loading="lazy"><br>
线程在生命周期中并不是固定处于某一个状态，而是随着代码的执行在不同状态之间切换，Java线程状态变迁如下图：<br>
<img src="https://wylovecoding.github.io/post-images/1617712675891.png" alt="" loading="lazy"></p>
<ul>
<li>线程创建之后它处于new（新建）状态</li>
<li>调用start()方法后开始运行，线程这时候处于ready（可运行）状态，可运行状态的线程获得了CPU时间片之后就处于running（运行）状态。（Java中一般将ready &lt;--&gt; running 这两个状态统称为Runnable（运行中）状态）。</li>
<li>当线程执行wait()方法之后，线程进入waiting（等待）状态，进入等待状态的线程需要依靠其它线程的通知才能返回运行状态。</li>
<li>而timed_waiting（计时等待）状态相当云在等待状态的基础上增加了计时限制，比如通过sleep(long millis)方法或wait(long millis)方法可以将Java线程置于计时等待状态。当计时时间到达后Java线程将会返回到Runnable状态。</li>
<li>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到blocked（阻塞）状态。</li>
<li>线程在run()方法执行完毕之后会进入到terminated（终止）状态。</li>
</ul>
<h2 id="16-上下文切换">1.6 上下文切换</h2>
<p>通常在并发编程中线程的个数要大于CPU核的个数，而一个CPU核在任意时刻只能被一个线程使用，为了让这些线程都能得到有效的执行，CPU采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态把CPU让给其它线程使用，这个过程就属于一次上下文切换。</p>
<p>概括来讲就是当前任务在执行完CPU的时间片，切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<h2 id="17-死锁">1.7 死锁</h2>
<h3 id="171-认识死锁">1.7.1 认识死锁</h3>
<blockquote>
<p><strong>线程死锁</strong>描述的是这样一种情况：多个线程同时被阻塞，他们中的一个或者全部都在等待某个资源被释放，由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
</blockquote>
<p>如下图所示，线程A持有资源2，线程B持有资源1，他们同时都想申请对方的资源，所以这俩线程会因为互相等待而进入死锁状态。<br>
<img src="https://wylovecoding.github.io/post-images/1617714358106.png" alt="" loading="lazy"><br>
下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p>
<pre><code>public class DeadLockDemo {
    private static Object resource1 = new Object();//资源 1
    private static Object resource2 = new Object();//资源 2

    public static void main(String[] args) {
        new Thread(() -&gt; {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + &quot;get resource1&quot;);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;);
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + &quot;get resource2&quot;);
                }
            }
        }, &quot;线程 1&quot;).start();

        new Thread(() -&gt; {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + &quot;get resource2&quot;);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + &quot;waiting get resource1&quot;);
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + &quot;get resource1&quot;);
                }
            }
        }, &quot;线程 2&quot;).start();
    }
}
</code></pre>
<p>输出如下：</p>
<pre><code>Thread[线程 1,5,main]get resource1
Thread[线程 2,5,main]get resource2
Thread[线程 1,5,main]waiting get resource2
Thread[线程 2,5,main]waiting get resource1
</code></pre>
<p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件：</p>
<ol>
<li><strong>互斥条件</strong>：该资源任意时刻只有一个线程占用。</li>
<li><strong>请求与保持条件</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件</strong>：线程已获得的资源在未使用完之前不能被其它线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li><strong>循环等待条件</strong>：若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h3 id="172-避免死锁">1.7.2 避免死锁</h3>
<p>上面说了产生死锁的四个必要条件，为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。现在我们来挨个分析一下：</p>
<ol>
<li><strong>破坏互斥条件</strong>：这个条件我们无法破坏，因为我们使用锁本来就是想让他们互斥的。</li>
<li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源</li>
<li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其它资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong>：可以依靠“按序申请资源”来预防。按某一顺序申请资源，释放资源则反序释放，破坏循环等待条件。</li>
</ol>
<h2 id="18-为什么我们调用start方法时会执行run方法为什么我们不能直接调用run方法">1.8 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法</h2>
<p>调用start()方法可以启动线程并使线程进入就绪状态，而直接执行run()方法的话会把run方法当成main线程下的一个普通方法，不会以多线程的方式运行。</p>
<h2 id="19-sleep方法和wait方法的区别与共同点">1.9 sleep()方法和wait()方法的区别与共同点</h2>
<ul>
<li>这两个方法最本质的区别在于sleep()方法没有释放锁，而wait()方法释放了锁。</li>
<li>两者都可以暂停线程的执行</li>
<li>wait()通常用于线程间交互/通信，sleep()方法通常被用于暂停执行</li>
<li>wait()方法被调用完后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)方法，超时后线程会自动苏醒。</li>
</ul>
<h2 id="110-synchronized关键字">1.10 Synchronized关键字</h2>
<h2 id="111-cpu高速缓存">1.11 CPU高速缓存</h2>
<h2 id="112-volatile关键字">1.12 volatile关键字</h2>
<h2 id="113-synchronized关键字和volatile关键字的区别">1.13 Synchronized关键字和volatile关键字的区别</h2>
<h2 id="114-线程池">1.14 线程池</h2>
<h3 id="1141-为什么使用线程池">1.14.1 为什么使用线程池</h3>
<h3 id="1142-实现runnable接口和callable接口的区别">1.14.2 实现Runnable接口和Callable接口的区别</h3>
<h3 id="1143-执行execute方法和submit方法的区别">1.14.3 执行execute()方法和submit()方法的区别</h3>
<h3 id="1144-创建线程池">1.14.4 创建线程池</h3>
<h2 id="115-atomic原子类">1.15 Atomic原子类</h2>
<h2 id="116-countdownlatch">1.16 CountDownLatch</h2>

            </div>
          </article>
        </div>
        <div class="paper" data-aos="fade-in">
          
            <div class="next-post">
              <div class="next">
                下一篇
              </div>
              <a href="https://wylovecoding.github.io/post/jing-dian-kuai-su-pai-xu-suan-fa-java-shi-xian/">
                <h3 class="post-title">
                  经典快速排序算法Java实现
                </h3>
              </a>
            </div>
          
        </div>
        
          
            <div class="paper" data-aos="fade-in">
              <div id="gitalk-container"></div>
            </div>
          

          
        
      </div>

      <div class="sm-12 md-4 col sidebar">
  <div class="paper info-container">
    <img src="https://wylovecoding.github.io/images/avatar.png?v=1617756339348" class="no-responsive avatar">
    <div class="text-muted">心中无女人，编码自然神(●'◡'●)</div>
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      最新文章
    </div>
    <div class="row">
      <ul>
        
          
            <li>
              <a href="https://wylovecoding.github.io/post/java-duo-xian-cheng-xue-xi-zong-jie/">Java多线程学习总结</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecoding.github.io/post/jing-dian-kuai-su-pai-xu-suan-fa-java-shi-xian/">经典快速排序算法Java实现</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecoding.github.io/post/pai-xu-dui-pai-xu/">排序——堆排序</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-er-cha-sou-suo-pai-xu-shu-de-shi-xian/">数据结构学习——二叉搜索（排序）树的实现</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-shu-er/">数据结构学习——树（二）</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-shu-yi/">数据结构学习——树（一）</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-dui-lie-yi/">数据结构学习——队列</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-zhan-er/">数据结构学习——栈（二）</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-zhan-yi/">数据结构学习——栈（一）</a>
            </li>
          
        
          
            <li>
              <a href="https://wylovecoding.github.io/post/about/">关于</a>
            </li>
          
        
      </ul>
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      标签列表
    </div>
    <div class="row">
      
        <a href="https://wylovecoding.github.io/tag/q70utjvai/" class="badge success">
          算法学习
        </a>
      
        <a href="https://wylovecoding.github.io/tag/ov8AxLVRR/" class="badge secondary">
          Java
        </a>
      
        <a href="https://wylovecoding.github.io/tag/Cy8dFWKpa/" class="badge warning">
          数据结构学习
        </a>
      
    </div>
  </div>
  <div class="paper">
    Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://wylovecoding.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>


    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '0336ce3b4548dfa0ca0c',
        clientSecret: '6ac1508cfb95a6b54215894ea49a6e18920e546f',
        repo: 'wylovecoding.github.io',
        owner: 'wyLoveCoding',
        admin: ['wyLoveCoding'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
