<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>Java多线程学习总结 | 我爱刷题</title>

<link rel="shortcut icon" href="https://wylovecoding.github.io/favicon.ico?v=1617874742542">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://wylovecoding.github.io/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<style>
    hr {
        margin-top: 1rem;
        margin-bottom: 1rem;
        border: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <style>
    /* 导航栏样式 */
    .navbar {
        position: relative;
        display: -ms-flexbox;
        display: flex;
        -ms-flex-wrap: wrap;
        flex-wrap: wrap;
        -ms-flex-align: center;
        align-items: center;
        -ms-flex-pack: justify;
        justify-content: space-between;
        padding: 0.5rem 1rem;
    }

    .navbar-brand {
        display: inline-block;
        padding-top: 0.3125rem;
        padding-bottom: 0.3125rem;
        margin-right: 1rem;
        font-size: 1.25rem;
        line-height: inherit;
        white-space: nowrap;
    }

    .navbar-brand:hover,
    .navbar-brand:focus {
        text-decoration: none;
    }

    .navbar-nav {
        display: -ms-flexbox;
        display: flex;
        -ms-flex-direction: column;
        flex-direction: column;
        padding-left: 0;
        margin-bottom: 0;
        list-style: none;
    }

    .navbar-collapse {
        -ms-flex-preferred-size: 100%;
        flex-basis: 100%;
        -ms-flex-positive: 1;
        flex-grow: 1;
        -ms-flex-align: center;
        align-items: center;
    }

    .navbar-toggler {
        padding: 0.25rem 0.75rem;
        font-size: 1.25rem;
        line-height: 1;
        background-color: transparent;
        border: 1px solid transparent;
        border-radius: 0.25rem;
    }

    .navbar-toggler:hover,
    .navbar-toggler:focus {
        text-decoration: none;
    }

    @media (min-width: 992px) {
        .navbar-expand-lg {
            -ms-flex-flow: row nowrap;
            flex-flow: row nowrap;
            -ms-flex-pack: start;
            justify-content: flex-start;
        }

        .navbar-expand-lg .navbar-nav {
            -ms-flex-direction: row;
            flex-direction: row;
        }

        .navbar-expand-lg .navbar-collapse {
            display: -ms-flexbox !important;
            display: flex !important;
            -ms-flex-preferred-size: auto;
            flex-basis: auto;
        }

        .navbar-expand-lg .navbar-toggler {
            display: none;
        }
    }

    @media (max-width: 991px) {
        #navbarSupportedContent {
            display: none;
        }
    }
</style>
<nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            我爱刷题
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1617874742542"
                action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function () {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Java多线程学习总结
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-04-06 ·
                    </time>
                    
                </div>
                <div class="post-content">
                    <h2 id="11-进程与线程">1.1 进程与线程</h2>
<h3 id="111-进程">1.1.1 进程</h3>
<blockquote>
<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即 是一个进程从创建、运行到消亡的过程。在Java中，当我们启动main函数，其实就是启动了一个JVM的进程，而main函数所在的线程就是这个进程中的一个线程，也称主线程。</p>
</blockquote>
<h3 id="112-线程">1.1.2 线程</h3>
<blockquote>
<p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源。但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。所以系统在产生一个线程，或者是在各个线程之间切换工作时，负担要比进程小的多，也正因如此，线程也被称作轻量级进程。</p>
</blockquote>
<h3 id="113-进程与线程之间的关系-区别及优缺点">1.1.3 进程与线程之间的关系、区别及优缺点</h3>
<p>从JVM角度讲进程和线程之间的关系<br>
下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。<br>
<img src="https://wylovecoding.github.io/post-images/1617710272956.png" alt="" loading="lazy"><br>
从上图可以看出：一个进程可以有多个线程，多个线程共享进程的堆和方法区，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</p>
<blockquote>
<p><strong>总结</strong>：线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而线程则不一定，因为同一进程中的线程很有可能会相互影响。线程执行开销小，但不利于资源的管理和保护，进程则恰恰相反。</p>
</blockquote>
<h2 id="12-并发与并行">1.2 并发与并行</h2>
<ul>
<li><strong>并发</strong>：同一时间段，多个任务都在执行（单位时间内不一定同时执行）</li>
<li><strong>并行</strong>：单位时间内，多个任务同时执行。</li>
</ul>
<h2 id="13-为什么要使用多线程">1.3 为什么要使用多线程</h2>
<ul>
<li><strong>从计算机底层来讲</strong>：线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核CPU时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来讲</strong>：现在的系统动不动就要求百万甚至千万级的并发量，而多线程并发编程正式开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<h2 id="14-使用多线程可能带来什么问题">1.4 使用多线程可能带来什么问题</h2>
<p>并发编程的目的就是为了能够提高程序的执行效率，但是也可能会遇到很多问题，诸如内存泄漏、死锁、上下文切换等。</p>
<h2 id="15-线程的生命周期和状态">1.5 线程的生命周期和状态</h2>
<p><img src="https://wylovecoding.github.io/post-images/1617712547983.png" alt="" loading="lazy"><br>
线程在生命周期中并不是固定处于某一个状态，而是随着代码的执行在不同状态之间切换，Java线程状态变迁如下图：<br>
<img src="https://wylovecoding.github.io/post-images/1617712675891.png" alt="" loading="lazy"></p>
<ul>
<li>线程创建之后它处于new（新建）状态</li>
<li>调用start()方法后开始运行，线程这时候处于ready（可运行）状态，可运行状态的线程获得了CPU时间片之后就处于running（运行）状态。（Java中一般将ready &lt;--&gt; running 这两个状态统称为Runnable（运行中）状态）。</li>
<li>当线程执行wait()方法之后，线程进入waiting（等待）状态，进入等待状态的线程需要依靠其它线程的通知才能返回运行状态。</li>
<li>而timed_waiting（计时等待）状态相当云在等待状态的基础上增加了计时限制，比如通过sleep(long millis)方法或wait(long millis)方法可以将Java线程置于计时等待状态。当计时时间到达后Java线程将会返回到Runnable状态。</li>
<li>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到blocked（阻塞）状态。</li>
<li>线程在run()方法执行完毕之后会进入到terminated（终止）状态。</li>
</ul>
<h2 id="16-上下文切换">1.6 上下文切换</h2>
<p>通常在并发编程中线程的个数要大于CPU核的个数，而一个CPU核在任意时刻只能被一个线程使用，为了让这些线程都能得到有效的执行，CPU采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态把CPU让给其它线程使用，这个过程就属于一次上下文切换。</p>
<p>概括来讲就是当前任务在执行完CPU的时间片，切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<h2 id="17-死锁">1.7 死锁</h2>
<h3 id="171-认识死锁">1.7.1 认识死锁</h3>
<blockquote>
<p><strong>线程死锁</strong>描述的是这样一种情况：多个线程同时被阻塞，他们中的一个或者全部都在等待某个资源被释放，由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
</blockquote>
<p>如下图所示，线程A持有资源2，线程B持有资源1，他们同时都想申请对方的资源，所以这俩线程会因为互相等待而进入死锁状态。<br>
<img src="https://wylovecoding.github.io/post-images/1617714358106.png" alt="" loading="lazy"><br>
下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p>
<pre><code>public class DeadLockDemo {
    private static Object resource1 = new Object();//资源 1
    private static Object resource2 = new Object();//资源 2

    public static void main(String[] args) {
        new Thread(() -&gt; {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + &quot;get resource1&quot;);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;);
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + &quot;get resource2&quot;);
                }
            }
        }, &quot;线程 1&quot;).start();

        new Thread(() -&gt; {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + &quot;get resource2&quot;);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + &quot;waiting get resource1&quot;);
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + &quot;get resource1&quot;);
                }
            }
        }, &quot;线程 2&quot;).start();
    }
}
</code></pre>
<p>输出如下：</p>
<pre><code>Thread[线程 1,5,main]get resource1
Thread[线程 2,5,main]get resource2
Thread[线程 1,5,main]waiting get resource2
Thread[线程 2,5,main]waiting get resource1
</code></pre>
<p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件：</p>
<ol>
<li><strong>互斥条件</strong>：该资源任意时刻只有一个线程占用。</li>
<li><strong>请求与保持条件</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件</strong>：线程已获得的资源在未使用完之前不能被其它线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li><strong>循环等待条件</strong>：若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h3 id="172-避免死锁">1.7.2 避免死锁</h3>
<p>上面说了产生死锁的四个必要条件，为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。现在我们来挨个分析一下：</p>
<ol>
<li><strong>破坏互斥条件</strong>：这个条件我们无法破坏，因为我们使用锁本来就是想让他们互斥的。</li>
<li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源</li>
<li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其它资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong>：可以依靠“按序申请资源”来预防。按某一顺序申请资源，释放资源则反序释放，破坏循环等待条件。</li>
</ol>
<h2 id="18-为什么我们调用start方法时会执行run方法为什么我们不能直接调用run方法">1.8 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法</h2>
<p>调用start()方法可以启动线程并使线程进入就绪状态，而直接执行run()方法的话会把run方法当成main线程下的一个普通方法，不会以多线程的方式运行。</p>
<h2 id="19-sleep方法和wait方法的区别与共同点">1.9 sleep()方法和wait()方法的区别与共同点</h2>
<ul>
<li>这两个方法最本质的区别在于sleep()方法没有释放锁，而wait()方法释放了锁。</li>
<li>两者都可以暂停线程的执行</li>
<li>wait()通常用于线程间交互/通信，sleep()方法通常被用于暂停执行</li>
<li>wait()方法被调用完后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)方法，超时后线程会自动苏醒。</li>
</ul>
<h2 id="110-synchronized关键字">1.10 Synchronized关键字</h2>
<h3 id="1101-synchronized关键字几种常见的使用形式">1.10.1 synchronized关键字几种常见的使用形式</h3>
<ol>
<li>修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。<pre><code>   synchronized void method() {
       //业务代码
    }
</code></pre>
</li>
<li>修饰静态方法：也就是给当前类加锁，会作用于类的所有对象实例，进入同步代码前要获得当前class的锁，因为静态成员不属于任何一个实例对象，是类成员（被static关键字修饰表示这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态的同步方法，而线程B需要调用这个实例对象所属类的静态的同步方法，是允许的，不会发生互斥现象。因为访问静态同步方法占用的锁是当前类的锁，而访问非静态的同步方法占用的锁是当前实例对象的锁。<pre><code>synchronized void staic method() {
    //业务代码
}
</code></pre>
</li>
<li>修饰代码块：指定加锁对象，对给定的对象/类加锁。synchronized(this|object)表示进入同步代码块前要获得给定对象的锁；synchronized(类.class)表示进入同步代码块前要获得当前class的锁。<pre><code>synchronized(this) {
//业务代码
}
</code></pre>
</li>
</ol>
<blockquote>
<p><strong>总结</strong>：</p>
<ul>
<li>synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给Class类上锁。</li>
<li>synchronized关键字加到实例方法上是给对象实例上锁。</li>
<li>尽量不要使用synchronized(String s)，因为JVM中字符串常量池具有缓存功能。</li>
</ul>
</blockquote>
<h3 id="1102-synchronized关键字的应用双重检验锁实现单例模式">1.10.2 synchronized关键字的应用——双重检验锁实现单例模式</h3>
<pre><code>public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}

</code></pre>
<h2 id="111-cpu高速缓存">1.11 CPU高速缓存</h2>
<h3 id="1111-为什么会有cpu-cache">1.11.1 为什么会有cpu cache</h3>
<blockquote>
<p>类比我们开发网站后台系统使用的缓存（如redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。cpu缓存则是为了解决cpu处理速度和内存处理速度不对等的问题。</p>
</blockquote>
<h3 id="1112-cpu-cache的工作方式">1.11.2 cpu cache的工作方式</h3>
<blockquote>
<p>先复制一份数据到cpu cache中，当cpu需要用到的时候就可以直接从cpu cache中读取数据，当运算完成后，再将运算得到的数据写回main memory中。但是这样存在内存、缓存不一致性的问题。比如我们执行一个i++操作，如果两个线程同时执行的话，假如从cpu cache读取到 i = 1，两个线程做了i++运算之后再写回main memory之后i等于2，而正确结果应该是3.</p>
</blockquote>
<h2 id="112-synchronized关键字和volatile关键字的区别">1.12 Synchronized关键字和volatile关键字的区别</h2>
<blockquote>
<p>synchronized关键字和volatile关键字是两个互补的存在，而不是对立的存在。</p>
</blockquote>
<ul>
<li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，但是volatile关键字只能用于变量，而synchronized关键字可以用来修饰方法及代码块。</li>
<li>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证</li>
<li>volatile关键字主要用来解决变量在多个线程之间的可见性，而synchronized关键字保证的是多个线程访问资源的同步性。</li>
</ul>
<h2 id="113-线程池">1.13 线程池</h2>
<h3 id="1131-为什么使用线程池">1.13.1 为什么使用线程池</h3>
<blockquote>
<p>池化技术相信大家已经屡见不鲜了，线程池、数据库连接池、http连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>
</blockquote>
<p>《Java并发编程的艺术》里面有讲到使用线程池的好处：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等待线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。</li>
</ul>
<h3 id="1132-实现runnable接口和callable接口的区别">1.13.2 实现Runnable接口和Callable接口的区别</h3>
<p>Runnable接口自Java1.0以来就一直存在，而Callable是在Java1.5引入的，目的就是为了处理Runnable不支持的用例。Runnable接口不会返回结果和抛出检擦异常，但是Callable接口可以。所以如果任务不需要返回结果或者抛出异常的话，推荐使用Runnable接口，这样代码看起来会更加简洁。</p>
<p>工具类Executors可以实现Runnable对象和Callable对象之间的相互转换。</p>
<pre><code>Executors.callable(Runnable task)
Executors.callable(Runnable task, Object result)
</code></pre>
<h3 id="1133-执行execute方法和submit方法的区别">1.13.3 执行execute()方法和submit()方法的区别</h3>
<ol>
<li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否。</li>
<li>submit()方法用于提交需要返回值的任务，线程池会返回一个Future类型的对象，通过这个Future对象可以判断任务是否执行成功，并且可以通过Future的get()方法来获取返回值。值得注意的是get()方法会阻塞当前线程直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ol>
<h3 id="1134-创建线程池">1.13.4 创建线程池</h3>
<p>《阿里巴巴Java开发手册》中强制线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式。这样的处理方式可以让编码的人更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li>FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li>
<li>CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
<p>我们可以通过ThreadPoolExcutor类的构造方法来创建线程池对象。<br>
<img src="https://wylovecoding.github.io/post-images/1617872211821.png" alt="" loading="lazy"></p>
<pre><code>    /**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize &lt; 0 ||
            maximumPoolSize &lt;= 0 ||
            maximumPoolSize &lt; corePoolSize ||
            keepAliveTime &lt; 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
</code></pre>
<h3 id="1135-threadpoolexecutor类构造方法重要参数解析">1.13.5 ThreadPoolExecutor类构造方法重要参数解析</h3>
<ul>
<li><strong>corePoolSize</strong>：核心线程数。定义了最小可以同时运行的线程数量。</li>
<li><strong>maximumPoolSize</strong>：当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong>keepAliveTime</strong>：当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime才会被回收销毁。</li>
<li><strong>unit</strong>：keepAliveTime参数的时间单位。</li>
<li><strong>workQueue</strong>：当新任务来的时候会判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列内。</li>
<li><strong>threadFactory</strong>：executor 创建新线程的时候会用到。</li>
<li><strong>handler</strong>：饱和策略（详见下节）。<br>
<img src="https://wylovecoding.github.io/post-images/1617873792500.png" alt="" loading="lazy"></li>
</ul>
<h3 id="1136-threadpoolexecutor的饱和策略">1.13.6 ThreadPoolExecutor的饱和策略</h3>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满的时候，ThreadPoolExecutor定义了一些策略：</p>
<ul>
<li><strong>ThreadPoolExecutor.AbortPolicy</strong>：抛出RejectedExecutionException来拒绝新任务</li>
<li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：在任务被拒绝添加后，会调用当前线程池的所在的线程去执行被拒绝的任务。有可能会阻塞主线程。</li>
<li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：不处理新任务，直接丢弃。</li>
<li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>：此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<h2 id="114-atomic原子类">1.14 Atomic原子类</h2>
<p><strong>Atomic</strong>翻译成中文是原子的意思。在化学上我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在Java中Atomic是指一个操作是不可中断的，即使是在多个线程一起执行的时候。一个操作一旦开始，就不会被其它线程干扰。</p>
<p>所以，所谓的原子类说简单点就是具有原子/原子操作特征的类。</p>
<h3 id="1141-javautilconcurrent包中的原子类">1.14.1 java.util.concurrent包中的原子类</h3>
<ol>
<li><strong>基本类型</strong>：使用原子的方式更新基本类型。
<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean：布尔型原子类</li>
</ul>
</li>
<li><strong>数组类型</strong>：使用原子的方式更新数组的每个元素。
<ul>
<li>AtomicIntegerArray：整形数组原子类</li>
<li>AtomicLongArray：长整形数组原子类</li>
<li>AtomicReferenceArray：引用类型数组原子类</li>
</ul>
</li>
<li><strong>引用类型</strong>
<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li>AtomicMarkableReference ：原子更新带有标记位的引用类型</li>
</ul>
</li>
<li><strong>对象的属性修改类型</strong>
<ul>
<li>AtomicIntegerFieldUpdater：原子更新整形字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型字段的更新器</li>
</ul>
</li>
</ol>
<h2 id="115-countdownlatch">1.15 CountDownLatch</h2>
<p>CountDownLatch 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://wylovecoding.github.io/post/jing-dian-kuai-su-pai-xu-suan-fa-java-shi-xian/" class="post-title gt-a-link">
                    经典快速排序算法Java实现
                </a>
            </div>
        

        

        
            
                <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>
<script>
    // md5.min.js
    !function(n){
        "use strict";
        function d(n,t){var r=(65535&n)+(65535&t);return(n>>16)+(t>>16)+(r>>16)<<16|65535&r}
        function f(n,t,r,e,o,u){return d((c=d(d(t,n),d(e,u)))<<(f=o)|c>>>32-f,r);var c,f}
        function l(n,t,r,e,o,u,c){return f(t&r|~t&e,n,t,o,u,c)}
        function v(n,t,r,e,o,u,c){return f(t&e|r&~e,n,t,o,u,c)}
        function g(n,t,r,e,o,u,c){return f(t^r^e,n,t,o,u,c)}
        function m(n,t,r,e,o,u,c){return f(r^(t|~e),n,t,o,u,c)}
        function i(n,t){var r,e,o,u,c;n[t>>5]|=128<<t%32,n[14+(t+64>>>9<<4)]=t;var f=1732584193,i=-271733879,a=-1732584194,h=271733878;for(r=0;r<n.length;r+=16)f=l(e=f,o=i,u=a,c=h,n[r],7,-680876936),h=l(h,f,i,a,n[r+1],12,-389564586),a=l(a,h,f,i,n[r+2],17,606105819),i=l(i,a,h,f,n[r+3],22,-1044525330),f=l(f,i,a,h,n[r+4],7,-176418897),h=l(h,f,i,a,n[r+5],12,1200080426),a=l(a,h,f,i,n[r+6],17,-1473231341),i=l(i,a,h,f,n[r+7],22,-45705983),f=l(f,i,a,h,n[r+8],7,1770035416),h=l(h,f,i,a,n[r+9],12,-1958414417),a=l(a,h,f,i,n[r+10],17,-42063),i=l(i,a,h,f,n[r+11],22,-1990404162),f=l(f,i,a,h,n[r+12],7,1804603682),h=l(h,f,i,a,n[r+13],12,-40341101),a=l(a,h,f,i,n[r+14],17,-1502002290),f=v(f,i=l(i,a,h,f,n[r+15],22,1236535329),a,h,n[r+1],5,-165796510),h=v(h,f,i,a,n[r+6],9,-1069501632),a=v(a,h,f,i,n[r+11],14,643717713),i=v(i,a,h,f,n[r],20,-373897302),f=v(f,i,a,h,n[r+5],5,-701558691),h=v(h,f,i,a,n[r+10],9,38016083),a=v(a,h,f,i,n[r+15],14,-660478335),i=v(i,a,h,f,n[r+4],20,-405537848),f=v(f,i,a,h,n[r+9],5,568446438),h=v(h,f,i,a,n[r+14],9,-1019803690),a=v(a,h,f,i,n[r+3],14,-187363961),i=v(i,a,h,f,n[r+8],20,1163531501),f=v(f,i,a,h,n[r+13],5,-1444681467),h=v(h,f,i,a,n[r+2],9,-51403784),a=v(a,h,f,i,n[r+7],14,1735328473),f=g(f,i=v(i,a,h,f,n[r+12],20,-1926607734),a,h,n[r+5],4,-378558),h=g(h,f,i,a,n[r+8],11,-2022574463),a=g(a,h,f,i,n[r+11],16,1839030562),i=g(i,a,h,f,n[r+14],23,-35309556),f=g(f,i,a,h,n[r+1],4,-1530992060),h=g(h,f,i,a,n[r+4],11,1272893353),a=g(a,h,f,i,n[r+7],16,-155497632),i=g(i,a,h,f,n[r+10],23,-1094730640),f=g(f,i,a,h,n[r+13],4,681279174),h=g(h,f,i,a,n[r],11,-358537222),a=g(a,h,f,i,n[r+3],16,-722521979),i=g(i,a,h,f,n[r+6],23,76029189),f=g(f,i,a,h,n[r+9],4,-640364487),h=g(h,f,i,a,n[r+12],11,-421815835),a=g(a,h,f,i,n[r+15],16,530742520),f=m(f,i=g(i,a,h,f,n[r+2],23,-995338651),a,h,n[r],6,-198630844),h=m(h,f,i,a,n[r+7],10,1126891415),a=m(a,h,f,i,n[r+14],15,-1416354905),i=m(i,a,h,f,n[r+5],21,-57434055),f=m(f,i,a,h,n[r+12],6,1700485571),h=m(h,f,i,a,n[r+3],10,-1894986606),a=m(a,h,f,i,n[r+10],15,-1051523),i=m(i,a,h,f,n[r+1],21,-2054922799),f=m(f,i,a,h,n[r+8],6,1873313359),h=m(h,f,i,a,n[r+15],10,-30611744),a=m(a,h,f,i,n[r+6],15,-1560198380),i=m(i,a,h,f,n[r+13],21,1309151649),f=m(f,i,a,h,n[r+4],6,-145523070),h=m(h,f,i,a,n[r+11],10,-1120210379),a=m(a,h,f,i,n[r+2],15,718787259),i=m(i,a,h,f,n[r+9],21,-343485551),f=d(f,e),i=d(i,o),a=d(a,u),h=d(h,c);return[f,i,a,h]}
        function a(n){var t,r="",e=32*n.length;for(t=0;t<e;t+=8)r+=String.fromCharCode(n[t>>5]>>>t%32&255);return r}
        function h(n){var t,r=[];for(r[(n.length>>2)-1]=void 0,t=0;t<r.length;t+=1)r[t]=0;var e=8*n.length;for(t=0;t<e;t+=8)r[t>>5]|=(255&n.charCodeAt(t/8))<<t%32;return r}
        function e(n){var t,r,e="0123456789abcdef",o="";for(r=0;r<n.length;r+=1)t=n.charCodeAt(r),o+=e.charAt(t>>>4&15)+e.charAt(15&t);return o}
        function r(n){return unescape(encodeURIComponent(n))}
        function o(n){return a(i(h(t=r(n)),8*t.length));var t}
        function u(n,t){return function(n,t){var r,e,o=h(n),u=[],c=[];for(u[15]=c[15]=void 0,16<o.length&&(o=i(o,8*n.length)),r=0;r<16;r+=1)u[r]=909522486^o[r],c[r]=1549556828^o[r];return e=i(u.concat(h(t)),512+8*t.length),a(i(c.concat(e),640))}(r(n),r(t))}
        function t(n,t,r){return t?r?u(t,n):e(u(t,n)):r?o(n):e(o(n))}
        "function"==typeof define&&define.amd?define(function(){return t}):"object"==typeof module&&module.exports?module.exports=t:n.md5=t;
    }(this);
</script>


<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '0336ce3b4548dfa0ca0c',
    clientSecret: '6ac1508cfb95a6b54215894ea49a6e18920e546f',
    repo: 'wylovecoding.github.io',
    owner: 'wyLoveCoding',
    admin: ['wyLoveCoding'],
    id: md5(location.pathname),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false       // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

            

            
        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">心中无女人，编码自然神(●'◡'●)</div>
    <div class="social-container">
        
            
                <a href="https://github.com/wyLoveCoding" target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://wylovecoding.github.io/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
