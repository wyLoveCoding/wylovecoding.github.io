<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wylovecoding.github.io</id>
    <title>萌新求职记</title>
    <updated>2021-03-10T05:53:14.352Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wylovecoding.github.io"/>
    <link rel="self" href="https://wylovecoding.github.io/atom.xml"/>
    <subtitle>心中无女人，编码自然神(●&apos;◡&apos;●)</subtitle>
    <logo>https://wylovecoding.github.io/images/avatar.png</logo>
    <icon>https://wylovecoding.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 萌新求职记</rights>
    <entry>
        <title type="html"><![CDATA[经典快速排序算法Java实现]]></title>
        <id>https://wylovecoding.github.io/post/jing-dian-kuai-su-pai-xu-suan-fa-java-shi-xian/</id>
        <link href="https://wylovecoding.github.io/post/jing-dian-kuai-su-pai-xu-suan-fa-java-shi-xian/">
        </link>
        <updated>2021-03-10T02:18:28.000Z</updated>
        <content type="html"><![CDATA[<p>代码参考自《数据结构与算法分析Java语言描述》一书。</p>
<pre><code>public class QuickSort {

    public static void main(String[] args) {
        Integer[] arr = {5, 7, 4, 6, 2, 1, 9, 8, 10, 3};
//        System.out.println(median3(arr, 0, arr.length - 1));
        quickSort(arr);
        for (Integer i : arr)
            System.out.print(i + &quot; &quot;);
    }

    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void quickSort(T[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }
    /*
        取头、尾、中的中位数作为pivot
     */
    private static &lt;T extends Comparable&lt;? super T&gt;&gt; T median3(T[] arr, int left, int right) {
        int center = (left + right) &gt;&gt; 1;

        if (arr[center].compareTo(arr[left]) &gt; 0)
            swapReference(arr, left, center);
        if (arr[right].compareTo(arr[left]) &gt; 0)
            swapReference(arr, left, right);
        if (arr[right].compareTo(arr[center]) &gt; 0)
            swapReference(arr, right, center);

        swapReference(arr, center, right-1);

        return arr[right-1];
    }
    /*
        经典快速排序算法的实现，如果元素太少，直接用插入排序
     */
    private static &lt;T extends Comparable&lt;? super T&gt;&gt; void quickSort(T[] arr, int left, int right) {
        if (left + CUTOFF &lt;= right) {
            T pivot = median3(arr, left, right);
            int i = left + 1, j = right - 2;

            for ( ; ; ) {
                while (i &lt; right - 1 &amp;&amp; arr[i++].compareTo(pivot) &lt; 0);
                while (j &gt; left &amp;&amp; arr[j--].compareTo(pivot) &gt; 0);
                if (i &lt; j)
                    swapReference(arr, i, j);
                else
                    break;
            }

            swapReference(arr, i, right-1);

            quickSort(arr, left, i-1);
            quickSort(arr, i+1,  right);
        }else
            insertionSort(arr);
    }
    /*
        插入排序
     */
    private static &lt;T extends Comparable&lt;? super T&gt;&gt; void insertionSort(T[] arr) {
        for (int i = 1; i &lt; arr.length; i++) {
            for (int j = i; j &gt; 0; j--) {
                if (arr[j].compareTo(arr[j-1]) &lt; 0)
                    swapReference(arr, j, j-1);
            }
        }
    }

    private static &lt;T extends Comparable&lt;? super T&gt;&gt; void swapReference(T[] arr, int a, int b) {
        T tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
    private static final int CUTOFF = 8;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序——堆排序]]></title>
        <id>https://wylovecoding.github.io/post/pai-xu-dui-pai-xu/</id>
        <link href="https://wylovecoding.github.io/post/pai-xu-dui-pai-xu/">
        </link>
        <updated>2021-03-07T13:00:08.000Z</updated>
        <content type="html"><![CDATA[<p>堆排序的Java代码实现。</p>
<pre><code>public class HeapSort {
    public static void main(String[] args) {
        Integer[] arr = {5, 7, 4, 6, 2, 1, 9, 8, 10, 3};
        for (Integer i : heapSort(arr))
            System.out.print(i + &quot; &quot;);
    }

    /**
     * 排序
     * @param arr   待排序的数组
     * @param &lt;T&gt;   指定泛型方法
     * @return  返回排序后的数组
     */
    static &lt;T extends Comparable&lt;? super T&gt;&gt; T[] heapSort(T[] arr) {
        buildHeap(arr); //先建堆
        //将堆顶，即最大值与堆中最后一个元素交换我位置，并“删除”最后一个元素。
        for (int i = arr.length - 1; i &gt;= 1; i--) {
            T temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            heapify(arr, 0, i-1);
        }
        return arr;
    }

    /**
     * 建堆
     * @param arr   需要排序的数组
     * @param &lt;T&gt;   指定泛型方法
     */
    static &lt;T extends Comparable&lt;? super T&gt;&gt; void buildHeap(T[] arr) {
        int N = arr.length - 1; //最后一个结点的位置
        int index = (arr.length &gt;&gt; 1) - 1;  //从index位置开始调整，即最后一个非叶结点
        for (int i = index; i &gt;= 0; i--)
            heapify(arr, i, N);
    }

    /**
     * 调整堆
     * @param arr   待调整的数组
     * @param index 开始调整的位置
     * @param n 堆大小（最后一个元素的位置）
     * @param &lt;T&gt;   泛型方法
     */
    static &lt;T extends Comparable&lt;? super T&gt;&gt; void heapify(T[] arr, int index, int n) {
        int leftChild = (index &lt;&lt; 1) + 1;   //找到左子结点的位置
        int rightChild = (index &lt;&lt; 1) + 2;  //找到右子结点的位置
        int tempIndex;  //与当前结点比较的子结点位置

        //找到需要与当前结点比较的子结点位置
        if (leftChild &lt;= n &amp;&amp; rightChild &lt;= n)  //左右结点都存在
            tempIndex = arr[leftChild].compareTo(arr[rightChild]) &gt; 0 ? leftChild : rightChild;
        else if (leftChild &lt;= n)    //左结点存在
            tempIndex = leftChild;
        else if (rightChild &lt;= n)   //右结点存在
            tempIndex = rightChild;
        else                        //都不存在则说明当前结点为叶子结点，不需要调整
            return;
        //如果子结点比父结点大，不符合大根堆，进行调整。
        if (arr[tempIndex].compareTo(arr[index]) &gt; 0) {
            T tmp = arr[tempIndex];
            arr[tempIndex] = arr[index];
            arr[index] = tmp;
            //调整后，将当前结点置为子结点的位置，继续判断
            heapify(arr, tempIndex, n);
        }
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构学习——二叉搜索（排序）树的实现]]></title>
        <id>https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-er-cha-sou-suo-pai-xu-shu-de-shi-xian/</id>
        <link href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-er-cha-sou-suo-pai-xu-shu-de-shi-xian/">
        </link>
        <updated>2021-03-03T05:52:48.000Z</updated>
        <content type="html"><![CDATA[<p>下面将使用Java语言分别实现二叉搜索树的 判空、置空、 插入、 删除、 包含等操作。</p>
<pre><code>/*
    二叉查找树的实现
*/
public class BinarySearchTree &lt;T extends Comparable&lt;? super T&gt;&gt;{
    private static class BinaryNode&lt;T&gt; {
        //Constructors
        BinaryNode(T theElement) {
            this(theElement, null, null);
        }

        BinaryNode(T theElement, BinaryNode&lt;T&gt; lt, BinaryNode&lt;T&gt; rt) {
            element = theElement;
            left = lt;
            right = rt;
        }

        T element;
        BinaryNode&lt;T&gt; left;
        BinaryNode&lt;T&gt; right;
    }

    private BinaryNode&lt;T&gt; root;

    public BinarySearchTree() {
        root = null;
    }

    public void makeEmpty() {
        root = null;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public boolean contains(T t) {
        return contains(t, root);
    }

    public T findMin() {
        if ( isEmpty() ) throw new BufferUnderflowException();
        return findMin(root).element;
    }

    public T findMax() {
        if ( isEmpty() ) throw new BufferUnderflowException();
        return findMax(root).element;
    }

    public void insert(T t) {
        root = insert(t, root);
    }

    public void remove(T t) {
        root = remove(t, root);
        System.out.println(root.element);
    }

    public void printTree() {

    }

    /**
    * 使用递归进行匹配：将传入的值与根节点的值进行比较，若小于则继续去左子树比较，直到相等；反之则去右子树比较。
    * @param t -需要查找的元素
    * @param node -根节点
    * @return  存在则返回true；否则返回false
    */
    private boolean contains(T t, BinaryNode&lt;T&gt; node) {
        if (node == null)
            return false;

        int compareResult = t.compareTo(node.element);

        if (compareResult &lt; 0)
            return contains(t, node.left);
        else if (compareResult &gt; 0)
            return contains(t, node.right);
        else
            return true;
    }

    /**
    * 递归调用来找到树中的最小值。尽可能去访问左子树，直到其为叶子节点时，返回它。
    * @param node -根节点
    * @return 返回最小值所在的节点
    */
    private BinaryNode&lt;T&gt; findMin(BinaryNode&lt;T&gt; node) {
        if (node == null)
            return null;
        else if (node.left == null)
            return node;
        return findMin(node.left);
    }

    /**
    * 递归调用来找到树中的最大值。尽可能去访问右子树，直到其为叶子节点时，返回它。
    * @param node -根节点
    * @return 返回最大值所在的节点
    */
    private BinaryNode&lt;T&gt; findMax(BinaryNode&lt;T&gt; node) {
//        if (node == null)
//            return null;
//        else if (node.right == null)
//            return node;
//        return findMin(node.right);
        if (node != null)
            while (node.right != null)
                node = root.right;

        return node;
    }

    /**
    * 类似于contains操作，递归地去查找适合插入的位置；我们暂时不考虑插入重复元素时的操作
    * @param t -要插入的元素
    * @param node -根节点
    * @return 返回插入之后的根节点
    */
    private BinaryNode&lt;T&gt; insert(T t, BinaryNode&lt;T&gt; node) {
        if (node == null)
            return new BinaryNode&lt;&gt;(t, null, null);

        int compareResult = t.compareTo(node.element);

        if (compareResult &lt; 0)
            node.left = insert(t, node.left);
        else if (compareResult &gt; 0)
            node.right = insert(t, node.right);
        else
            /*我们先不考虑插入重复元素时的操作*/;

        return node;

    }

    private BinaryNode&lt;T&gt; remove(T t, BinaryNode&lt;T&gt; node) {
        if (node == null)
            return node;    //空树不做任何操作，直接返回。

        int compareResult = t.compareTo(node.element);

        if (compareResult &lt; 0) {
            node.left = remove(t, node.left);
        }else if (compareResult &gt; 0) {
            node.right = remove(t, node.right);
        }else if (node.left != null &amp;&amp; node.right != null){
            node.element = findMin(node.right).element;
            node.right = remove(node.element, node.right);
        }else
            node = (node.left != null) ? node.left : node.right;

        return node;
    }

    private void printTree(BinaryNode&lt;T&gt; node) {

    }
}

class Test02 {
    public static void main(String[] args) {
        BinarySearchTree&lt;Integer&gt; bst = new BinarySearchTree&lt;&gt;();
        bst.insert(5);
        bst.insert(3);
        bst.insert(7);
        bst.insert(1);
        bst.insert(4);
        bst.insert(6);
        bst.insert(8);
        bst.insert(9);

        bst.remove(4);

    }
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构学习——树（二）]]></title>
        <id>https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-shu-er/</id>
        <link href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-shu-er/">
        </link>
        <updated>2021-03-02T05:02:56.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>在计算机科学里，树的遍历（也称为树的搜索）是图的遍历的一种，指的是按照某种规则，不重复地访问某种树的所有节点的过程。具体的访问操作可能是检查节点的值、更新节点的值等。不同的遍历方式，其访问节点的顺序是不一样的。</li>
<li>先（根）序遍历：指的是尽可能先去访问根节点，直到该节点为叶子节点，然后对其左、右子树分别进行先序遍历的过程。（根-&gt;左-&gt;右）<br>
<img src="https://wylovecoding.github.io/post-images/1614662308407.png" alt="" loading="lazy"><br>
如图的节点访问顺序为：F-&gt;B-&gt;A-&gt;D-&gt;C-&gt;E-&gt;G-&gt;I-&gt;H</li>
<li>中（根）序遍历：指的是尽可能先去访问左子树，直到该节点为叶子节点，然后访问其根节点，最后对右子树进行中序遍历的过程。（左-&gt;根-&gt;右）<br>
<img src="https://wylovecoding.github.io/post-images/1614662831044.png" alt="" loading="lazy"><br>
如图的节点访问顺序为：A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;H-&gt;I</li>
<li>后（根）序遍历：指的是尽可能先去访问左子树，直到该节点为叶子节点，接着对右子树进行后序遍历，最后访问其根节点的过程。（左-&gt;右-&gt;根）<br>
<img src="https://wylovecoding.github.io/post-images/1614663344502.png" alt="" loading="lazy"><br>
如图的节点访问顺序为：A-&gt;C-&gt;E-&gt;D-&gt;B-&gt;H-&gt;I-&gt;G-&gt;F</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构学习——树（一）]]></title>
        <id>https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-shu-yi/</id>
        <link href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-shu-yi/">
        </link>
        <updated>2021-03-02T04:41:35.000Z</updated>
        <content type="html"><![CDATA[<p>💛1. 树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<pre><code>    ◾ 每个节点都只有有限个子节点或无子节点；
    ◾ 没有父节点的节点称为根节点；
    ◾ 每一个非根节点有且只有一个父节点；
    ◾ 除了根节点外，每个子节点可以分为多个不相交的子树；
    ◾ 树里面没有环路(cycle)
</code></pre>
<p><img src="https://wylovecoding.github.io/post-images/1614660213615.png" alt="" loading="lazy"><br>
💚2. 有关树的一些术语：</p>
<pre><code>        ◾ 节点的度：一个节点含有的子树的个数称为该节点的度；
        ◾ 树的度：一棵树中，最大的节点度称为树的度；
        ◾ 叶节点或终端节点：度为零的节点；
        ◾ 非终端节点或分支节点：度不为零的节点；
        ◾ 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；
        ◾  孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；
        ◾ 兄弟节点：具有相同父节点的节点互称为兄弟节点；
        ◾ 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
        ◾ 深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；
        ◾ 高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；
        ◾ 堂兄弟节点：父节点在同一层的节点互为堂兄弟；
        ◾ 节点的祖先：从根到该节点所经分支上的所有节点；
        ◾ 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。
        ◾ 森林：由m（m&gt;=0）棵互不相交的树的集合称为森林；
</code></pre>
<p>💙3. 树的种类：</p>
<pre><code>    ◾ 无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；
    ◾ 有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树； 　
    ◾ 二叉树：每个节点最多含有两个子树的树称为二叉树； 　　
    ◾ 完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树； 　　　
    ◾ 满二叉树：所有叶节点都在最底层的完全二叉树； 　　
    ◾ 平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树； 　　
    ◾ 排序二叉树(二叉查找树（英语：Binary Search Tree))：也称二叉搜索树、有序二叉树； 　
    ◾ 霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树； 　　
    ◾ B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。
</code></pre>
<p>💗4. 树的抽象：</p>
<table>
    <tr>
        <th>方法名</th>
        <th>描述</th>
    </tr>
    <tr>
        <td>getElement()</td>
        <td>返回存放于当前节点处的对象</td>
    </tr>
    <tr>
        <td>setElement(e)</td>
        <td>将对象 e 存入当前节点，并返回其中此前所存的内容</td>
    </tr>
    <tr>
        <td>getParent()</td>
        <td>返回当前节点的父节点</td>
    </tr>
    <tr>
        <td>getFirstChild()</td>
        <td>返回当前节点的长子</td>
    </tr>
    <tr>
        <td>getNextSibling()</td>
        <td>返回当前节点的最大弟弟</td>
    </tr>
</table>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构学习——队列]]></title>
        <id>https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-dui-lie-yi/</id>
        <link href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-dui-lie-yi/">
        </link>
        <updated>2021-03-01T06:06:57.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>同栈一样，队列（queue）也是表。然而使用队列时插入在一端进行删除在另一端进行。区别于栈的后进先出，队列是先进先出。</li>
<li>队列的基本操作有入队（enqueue），即在队尾（rear）插入一个元素；出队（dequeue），即删除队头（front）元素。</li>
<li>数组模拟实现队列。</li>
</ol>
<pre><code>class Test01{
    public static void main(String[] args) {
        QueueImpl&lt;Integer&gt; arr = new QueueImpl&lt;&gt;();
        arr.add(1);
        arr.add(2);
        arr.add(3);
        arr.add(4);
        arr.add(5);
        arr.add(6);
        System.out.println(arr.size()+&quot; &quot;+arr.isEmpty());
        while(!arr.isEmpty()){
            Integer temp = arr.remove();
            System.out.println(temp);
        }

    }
}

class QueueImpl&lt;T&gt; implements MyQueue&lt;T&gt;{
    private T[] data;
    private int size;
    private int front;
    private int rear;
    public QueueImpl() {
        data = (T[])new Object[3];
        size = 0;
        front = 0;
        rear = 0;
    }

    @Override
    public void add(T t) {
        if(isFull()){
            resize();
            front = 0;
        }
        rear = (front+size)%data.length;
        data[rear] = t;
        size++;
    }

    @Override
    public T remove() {
        if(isEmpty()){
            throw new RuntimeException(&quot;queue is empty!&quot;);
        }
        T tempData = data[front];
        data[front] = null;
        front = (front+1)%data.length;
        size--;
        return tempData;
    }

    @Override
    public int size() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public T front() {
        if(isEmpty()){
            throw new RuntimeException(&quot;queue is empty!&quot;);
        }
        return data[front];
    }

    public boolean isFull(){
        return size == data.length;
    }

    public void resize(){
        T[] tmp = (T[])new Object[data.length*2];
        System.arraycopy(data, 0, tmp, 0, data.length);
        data = tmp;
        tmp = null;
    }

}

interface MyQueue&lt;T&gt; {
    void add(T t);
    T remove();
    int size();
    boolean isEmpty();
    T front();
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构学习——栈（二）]]></title>
        <id>https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-zhan-er/</id>
        <link href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-zhan-er/">
        </link>
        <updated>2021-03-01T02:59:08.000Z</updated>
        <content type="html"><![CDATA[<p>使用栈实现数制转换</p>
<pre><code>/*
    使用栈来实现数制转换
 */
public class StackForNumberConversion {
    public static void numberConversion(int num, int numberSystem) {
        if (numberSystem &lt;= 0)
            System.out.println(&quot;The number to reserve must be bigger than zero !&quot;);

        Stack&lt;Integer&gt; s = new Stack&lt;&gt;();
        while (num &gt;= numberSystem){
            s.push(num % numberSystem);
            num = num / numberSystem;
        }
        s.push(num);

//        s.forEach(System.out::print);
        while (!s.isEmpty()) {
            System.out.print(s.pop());
        }



    }

    public static void main(String[] args) {
        numberConversion(12, 0);    
    }

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构学习——栈（一）]]></title>
        <id>https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-zhan-yi/</id>
        <link href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-zhan-yi/">
        </link>
        <updated>2021-03-01T02:17:28.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>栈（stack）是限制插入和删除只能在同一个位置（即栈顶）的表，有时也叫做后进先出（LIFO）表，对栈的基本操作有push进栈、pop出栈等。栈可以有两种实现方式分别是数组和链表，下面我们用链表来模拟栈的实现。</p>
</li>
<li>
<p>使用链表结构模拟栈的实现（Java语言）</p>
</li>
</ol>
<pre><code>/*
    栈的链表实现

 */
public class StackImpl_1&lt;T&gt; {
    private int size;   //栈的大小
    private Node head;  //栈顶元素

    /*
        栈的初始化
     */
    public StackImpl_1() {
        size = 0;
        head = null;
    }

    /**
     * 进栈操作
     * @param   t-即将进栈的元素
     */
        public void push(T t){
        Node newNode = new Node(t);
        if (size &gt; 0){
            newNode.next = head;
        }
        head = newNode;
        size ++;
    }

    /**
     * 出栈操作
     * @return 返回刚刚出栈的元素
     */
    public T pop(){
        if (size == 0)
            return null;
        else {
            Node deletedNode = head;
            head = head.next != null ? head.next : null;
            size --;
            return deletedNode.t;
        }
    }

    /**
     * top操作，获取栈顶元素
     * @return  返回栈顶元素
     */
    public T top(){
        return head != null ? head.t : null;
    }

    /**
     * 遍历栈
     * @param stack-
     */
    public void scanStack(StackImpl_1&lt;T&gt; stack){
        if (stack.size == 0)
            return;
        System.out.print(stack.pop() + &quot; &quot;);
        scanStack(stack);

    }

    private class Node{
        public T t;
        public Node next;

        public Node(T t) {
            this.t = t;
        }
    }

    public static void main(String[] args) {
        StackImpl_1&lt;String&gt; stack1 = new StackImpl_1&lt;&gt;();
        stack1.push(&quot;A&quot;);
        stack1.push(&quot;B&quot;);
        stack1.push(&quot;C&quot;);
        stack1.push(&quot;D&quot;);
        stack1.push(&quot;E&quot;);

        stack1.scanStack(stack1);
        System.out.println(stack1.top());

    }
}
</code></pre>
]]></content>
    </entry>
</feed>