<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wylovecoding.github.io</id>
    <title>我爱刷题</title>
    <updated>2021-04-07T00:25:13.228Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wylovecoding.github.io"/>
    <link rel="self" href="https://wylovecoding.github.io/atom.xml"/>
    <subtitle>心中无女人，编码自然神(●&apos;◡&apos;●)</subtitle>
    <logo>https://wylovecoding.github.io/images/avatar.png</logo>
    <icon>https://wylovecoding.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 我爱刷题</rights>
    <entry>
        <title type="html"><![CDATA[Java多线程学习总结]]></title>
        <id>https://wylovecoding.github.io/post/java-duo-xian-cheng-xue-xi-zong-jie/</id>
        <link href="https://wylovecoding.github.io/post/java-duo-xian-cheng-xue-xi-zong-jie/">
        </link>
        <updated>2021-04-06T10:55:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="11-进程与线程">1.1 进程与线程</h2>
<h3 id="111-进程">1.1.1 进程</h3>
<blockquote>
<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即 是一个进程从创建、运行到消亡的过程。在Java中，当我们启动main函数，其实就是启动了一个JVM的进程，而main函数所在的线程就是这个进程中的一个线程，也称主线程。</p>
</blockquote>
<h3 id="112-线程">1.1.2 线程</h3>
<blockquote>
<p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源。但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。所以系统在产生一个线程，或者是在各个线程之间切换工作时，负担要比进程小的多，也正因如此，线程也被称作轻量级进程。</p>
</blockquote>
<h3 id="113-进程与线程之间的关系-区别及优缺点">1.1.3 进程与线程之间的关系、区别及优缺点</h3>
<p>从JVM角度讲进程和线程之间的关系<br>
下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。<br>
<img src="https://wylovecoding.github.io/post-images/1617710272956.png" alt="" loading="lazy"><br>
从上图可以看出：一个进程可以有多个线程，多个线程共享进程的堆和方法区，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</p>
<blockquote>
<p><strong>总结</strong>：线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而线程则不一定，因为同一进程中的线程很有可能会相互影响。线程执行开销小，但不利于资源的管理和保护，进程则恰恰相反。</p>
</blockquote>
<h2 id="12-并发与并行">1.2 并发与并行</h2>
<ul>
<li><strong>并发</strong>：同一时间段，多个任务都在执行（单位时间内不一定同时执行）</li>
<li><strong>并行</strong>：单位时间内，多个任务同时执行。</li>
</ul>
<h2 id="13-为什么要使用多线程">1.3 为什么要使用多线程</h2>
<ul>
<li><strong>从计算机底层来讲</strong>：线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核CPU时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来讲</strong>：现在的系统动不动就要求百万甚至千万级的并发量，而多线程并发编程正式开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<h2 id="14-使用多线程可能带来什么问题">1.4 使用多线程可能带来什么问题</h2>
<p>并发编程的目的就是为了能够提高程序的执行效率，但是也可能会遇到很多问题，诸如内存泄漏、死锁、上下文切换等。</p>
<h2 id="15-线程的生命周期和状态">1.5 线程的生命周期和状态</h2>
<p><img src="https://wylovecoding.github.io/post-images/1617712547983.png" alt="" loading="lazy"><br>
线程在生命周期中并不是固定处于某一个状态，而是随着代码的执行在不同状态之间切换，Java线程状态变迁如下图：<br>
<img src="https://wylovecoding.github.io/post-images/1617712675891.png" alt="" loading="lazy"></p>
<ul>
<li>线程创建之后它处于new（新建）状态</li>
<li>调用start()方法后开始运行，线程这时候处于ready（可运行）状态，可运行状态的线程获得了CPU时间片之后就处于running（运行）状态。（Java中一般将ready &lt;--&gt; running 这两个状态统称为Runnable（运行中）状态）。</li>
<li>当线程执行wait()方法之后，线程进入waiting（等待）状态，进入等待状态的线程需要依靠其它线程的通知才能返回运行状态。</li>
<li>而timed_waiting（计时等待）状态相当云在等待状态的基础上增加了计时限制，比如通过sleep(long millis)方法或wait(long millis)方法可以将Java线程置于计时等待状态。当计时时间到达后Java线程将会返回到Runnable状态。</li>
<li>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到blocked（阻塞）状态。</li>
<li>线程在run()方法执行完毕之后会进入到terminated（终止）状态。</li>
</ul>
<h2 id="16-上下文切换">1.6 上下文切换</h2>
<p>通常在并发编程中线程的个数要大于CPU核的个数，而一个CPU核在任意时刻只能被一个线程使用，为了让这些线程都能得到有效的执行，CPU采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态把CPU让给其它线程使用，这个过程就属于一次上下文切换。</p>
<p>概括来讲就是当前任务在执行完CPU的时间片，切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<h2 id="17-死锁">1.7 死锁</h2>
<h3 id="171-认识死锁">1.7.1 认识死锁</h3>
<blockquote>
<p><strong>线程死锁</strong>描述的是这样一种情况：多个线程同时被阻塞，他们中的一个或者全部都在等待某个资源被释放，由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
</blockquote>
<p>如下图所示，线程A持有资源2，线程B持有资源1，他们同时都想申请对方的资源，所以这俩线程会因为互相等待而进入死锁状态。<br>
<img src="https://wylovecoding.github.io/post-images/1617714358106.png" alt="" loading="lazy"><br>
下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p>
<pre><code>public class DeadLockDemo {
    private static Object resource1 = new Object();//资源 1
    private static Object resource2 = new Object();//资源 2

    public static void main(String[] args) {
        new Thread(() -&gt; {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + &quot;get resource1&quot;);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;);
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + &quot;get resource2&quot;);
                }
            }
        }, &quot;线程 1&quot;).start();

        new Thread(() -&gt; {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + &quot;get resource2&quot;);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + &quot;waiting get resource1&quot;);
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + &quot;get resource1&quot;);
                }
            }
        }, &quot;线程 2&quot;).start();
    }
}
</code></pre>
<p>输出如下：</p>
<pre><code>Thread[线程 1,5,main]get resource1
Thread[线程 2,5,main]get resource2
Thread[线程 1,5,main]waiting get resource2
Thread[线程 2,5,main]waiting get resource1
</code></pre>
<p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件：</p>
<ol>
<li><strong>互斥条件</strong>：该资源任意时刻只有一个线程占用。</li>
<li><strong>请求与保持条件</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件</strong>：线程已获得的资源在未使用完之前不能被其它线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li><strong>循环等待条件</strong>：若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h3 id="172-避免死锁">1.7.2 避免死锁</h3>
<p>上面说了产生死锁的四个必要条件，为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。现在我们来挨个分析一下：</p>
<ol>
<li><strong>破坏互斥条件</strong>：这个条件我们无法破坏，因为我们使用锁本来就是想让他们互斥的。</li>
<li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源</li>
<li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其它资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong>：可以依靠“按序申请资源”来预防。按某一顺序申请资源，释放资源则反序释放，破坏循环等待条件。</li>
</ol>
<h2 id="18-为什么我们调用start方法时会执行run方法为什么我们不能直接调用run方法">1.8 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法</h2>
<p>调用start()方法可以启动线程并使线程进入就绪状态，而直接执行run()方法的话会把run方法当成main线程下的一个普通方法，不会以多线程的方式运行。</p>
<h2 id="19-sleep方法和wait方法的区别与共同点">1.9 sleep()方法和wait()方法的区别与共同点</h2>
<ul>
<li>这两个方法最本质的区别在于sleep()方法没有释放锁，而wait()方法释放了锁。</li>
<li>两者都可以暂停线程的执行</li>
<li>wait()通常用于线程间交互/通信，sleep()方法通常被用于暂停执行</li>
<li>wait()方法被调用完后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)方法，超时后线程会自动苏醒。</li>
</ul>
<h2 id="110-synchronized关键字">1.10 Synchronized关键字</h2>
<h2 id="111-cpu高速缓存">1.11 CPU高速缓存</h2>
<h2 id="112-volatile关键字">1.12 volatile关键字</h2>
<h2 id="113-synchronized关键字和volatile关键字的区别">1.13 Synchronized关键字和volatile关键字的区别</h2>
<h2 id="114-线程池">1.14 线程池</h2>
<h3 id="1141-为什么使用线程池">1.14.1 为什么使用线程池</h3>
<h3 id="1142-实现runnable接口和callable接口的区别">1.14.2 实现Runnable接口和Callable接口的区别</h3>
<h3 id="1143-执行execute方法和submit方法的区别">1.14.3 执行execute()方法和submit()方法的区别</h3>
<h3 id="1144-创建线程池">1.14.4 创建线程池</h3>
<h2 id="115-atomic原子类">1.15 Atomic原子类</h2>
<h2 id="116-countdownlatch">1.16 CountDownLatch</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[经典快速排序算法Java实现]]></title>
        <id>https://wylovecoding.github.io/post/jing-dian-kuai-su-pai-xu-suan-fa-java-shi-xian/</id>
        <link href="https://wylovecoding.github.io/post/jing-dian-kuai-su-pai-xu-suan-fa-java-shi-xian/">
        </link>
        <updated>2021-03-10T02:18:28.000Z</updated>
        <content type="html"><![CDATA[<p>代码参考自《数据结构与算法分析Java语言描述》一书。</p>
<pre><code>public class QuickSort {

    public static void main(String[] args) {
        Integer[] arr = {5, 7, 4, 6, 2, 1, 9, 8, 10, 3};
//        System.out.println(median3(arr, 0, arr.length - 1));
        quickSort(arr);
        for (Integer i : arr)
            System.out.print(i + &quot; &quot;);
    }

    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void quickSort(T[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }
    /*
        取头、尾、中的中位数作为pivot
     */
    private static &lt;T extends Comparable&lt;? super T&gt;&gt; T median3(T[] arr, int left, int right) {
        int center = (left + right) &gt;&gt; 1;

        if (arr[center].compareTo(arr[left]) &gt; 0)
            swapReference(arr, left, center);
        if (arr[right].compareTo(arr[left]) &gt; 0)
            swapReference(arr, left, right);
        if (arr[right].compareTo(arr[center]) &gt; 0)
            swapReference(arr, right, center);

        swapReference(arr, center, right-1);

        return arr[right-1];
    }
    /*
        经典快速排序算法的实现，如果元素太少，直接用插入排序
     */
    private static &lt;T extends Comparable&lt;? super T&gt;&gt; void quickSort(T[] arr, int left, int right) {
        if (left + CUTOFF &lt;= right) {
            T pivot = median3(arr, left, right);
            int i = left + 1, j = right - 2;

            for ( ; ; ) {
                while (i &lt; right - 1 &amp;&amp; arr[i++].compareTo(pivot) &lt; 0);
                while (j &gt; left &amp;&amp; arr[j--].compareTo(pivot) &gt; 0);
                if (i &lt; j)
                    swapReference(arr, i, j);
                else
                    break;
            }

            swapReference(arr, i, right-1);

            quickSort(arr, left, i-1);
            quickSort(arr, i+1,  right);
        }else
            insertionSort(arr);
    }
    /*
        插入排序
     */
    private static &lt;T extends Comparable&lt;? super T&gt;&gt; void insertionSort(T[] arr) {
        for (int i = 1; i &lt; arr.length; i++) {
            for (int j = i; j &gt; 0; j--) {
                if (arr[j].compareTo(arr[j-1]) &lt; 0)
                    swapReference(arr, j, j-1);
            }
        }
    }

    private static &lt;T extends Comparable&lt;? super T&gt;&gt; void swapReference(T[] arr, int a, int b) {
        T tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
    private static final int CUTOFF = 8;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序——堆排序]]></title>
        <id>https://wylovecoding.github.io/post/pai-xu-dui-pai-xu/</id>
        <link href="https://wylovecoding.github.io/post/pai-xu-dui-pai-xu/">
        </link>
        <updated>2021-03-07T13:00:08.000Z</updated>
        <content type="html"><![CDATA[<p>堆排序的Java代码实现。</p>
<pre><code>public class HeapSort {
    public static void main(String[] args) {
        Integer[] arr = {5, 7, 4, 6, 2, 1, 9, 8, 10, 3};
        for (Integer i : heapSort(arr))
            System.out.print(i + &quot; &quot;);
    }

    /**
     * 排序
     * @param arr   待排序的数组
     * @param &lt;T&gt;   指定泛型方法
     * @return  返回排序后的数组
     */
    static &lt;T extends Comparable&lt;? super T&gt;&gt; T[] heapSort(T[] arr) {
        buildHeap(arr); //先建堆
        //将堆顶，即最大值与堆中最后一个元素交换我位置，并“删除”最后一个元素。
        for (int i = arr.length - 1; i &gt;= 1; i--) {
            T temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            heapify(arr, 0, i-1);
        }
        return arr;
    }

    /**
     * 建堆
     * @param arr   需要排序的数组
     * @param &lt;T&gt;   指定泛型方法
     */
    static &lt;T extends Comparable&lt;? super T&gt;&gt; void buildHeap(T[] arr) {
        int N = arr.length - 1; //最后一个结点的位置
        int index = (arr.length &gt;&gt; 1) - 1;  //从index位置开始调整，即最后一个非叶结点
        for (int i = index; i &gt;= 0; i--)
            heapify(arr, i, N);
    }

    /**
     * 调整堆
     * @param arr   待调整的数组
     * @param index 开始调整的位置
     * @param n 堆大小（最后一个元素的位置）
     * @param &lt;T&gt;   泛型方法
     */
    static &lt;T extends Comparable&lt;? super T&gt;&gt; void heapify(T[] arr, int index, int n) {
        int leftChild = (index &lt;&lt; 1) + 1;   //找到左子结点的位置
        int rightChild = (index &lt;&lt; 1) + 2;  //找到右子结点的位置
        int tempIndex;  //与当前结点比较的子结点位置

        //找到需要与当前结点比较的子结点位置
        if (leftChild &lt;= n &amp;&amp; rightChild &lt;= n)  //左右结点都存在
            tempIndex = arr[leftChild].compareTo(arr[rightChild]) &gt; 0 ? leftChild : rightChild;
        else if (leftChild &lt;= n)    //左结点存在
            tempIndex = leftChild;
        else if (rightChild &lt;= n)   //右结点存在
            tempIndex = rightChild;
        else                        //都不存在则说明当前结点为叶子结点，不需要调整
            return;
        //如果子结点比父结点大，不符合大根堆，进行调整。
        if (arr[tempIndex].compareTo(arr[index]) &gt; 0) {
            T tmp = arr[tempIndex];
            arr[tempIndex] = arr[index];
            arr[index] = tmp;
            //调整后，将当前结点置为子结点的位置，继续判断
            heapify(arr, tempIndex, n);
        }
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构学习——二叉搜索（排序）树的实现]]></title>
        <id>https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-er-cha-sou-suo-pai-xu-shu-de-shi-xian/</id>
        <link href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-er-cha-sou-suo-pai-xu-shu-de-shi-xian/">
        </link>
        <updated>2021-03-03T05:52:48.000Z</updated>
        <content type="html"><![CDATA[<p>下面将使用Java语言分别实现二叉搜索树的 判空、置空、 插入、 删除、 包含等操作。</p>
<pre><code>/*
    二叉查找树的实现
*/
public class BinarySearchTree &lt;T extends Comparable&lt;? super T&gt;&gt;{
    private static class BinaryNode&lt;T&gt; {
        //Constructors
        BinaryNode(T theElement) {
            this(theElement, null, null);
        }

        BinaryNode(T theElement, BinaryNode&lt;T&gt; lt, BinaryNode&lt;T&gt; rt) {
            element = theElement;
            left = lt;
            right = rt;
        }

        T element;
        BinaryNode&lt;T&gt; left;
        BinaryNode&lt;T&gt; right;
    }

    private BinaryNode&lt;T&gt; root;

    public BinarySearchTree() {
        root = null;
    }

    public void makeEmpty() {
        root = null;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public boolean contains(T t) {
        return contains(t, root);
    }

    public T findMin() {
        if ( isEmpty() ) throw new BufferUnderflowException();
        return findMin(root).element;
    }

    public T findMax() {
        if ( isEmpty() ) throw new BufferUnderflowException();
        return findMax(root).element;
    }

    public void insert(T t) {
        root = insert(t, root);
    }

    public void remove(T t) {
        root = remove(t, root);
        System.out.println(root.element);
    }

    public void printTree() {

    }

    /**
    * 使用递归进行匹配：将传入的值与根节点的值进行比较，若小于则继续去左子树比较，直到相等；反之则去右子树比较。
    * @param t -需要查找的元素
    * @param node -根节点
    * @return  存在则返回true；否则返回false
    */
    private boolean contains(T t, BinaryNode&lt;T&gt; node) {
        if (node == null)
            return false;

        int compareResult = t.compareTo(node.element);

        if (compareResult &lt; 0)
            return contains(t, node.left);
        else if (compareResult &gt; 0)
            return contains(t, node.right);
        else
            return true;
    }

    /**
    * 递归调用来找到树中的最小值。尽可能去访问左子树，直到其为叶子节点时，返回它。
    * @param node -根节点
    * @return 返回最小值所在的节点
    */
    private BinaryNode&lt;T&gt; findMin(BinaryNode&lt;T&gt; node) {
        if (node == null)
            return null;
        else if (node.left == null)
            return node;
        return findMin(node.left);
    }

    /**
    * 递归调用来找到树中的最大值。尽可能去访问右子树，直到其为叶子节点时，返回它。
    * @param node -根节点
    * @return 返回最大值所在的节点
    */
    private BinaryNode&lt;T&gt; findMax(BinaryNode&lt;T&gt; node) {
//        if (node == null)
//            return null;
//        else if (node.right == null)
//            return node;
//        return findMin(node.right);
        if (node != null)
            while (node.right != null)
                node = root.right;

        return node;
    }

    /**
    * 类似于contains操作，递归地去查找适合插入的位置；我们暂时不考虑插入重复元素时的操作
    * @param t -要插入的元素
    * @param node -根节点
    * @return 返回插入之后的根节点
    */
    private BinaryNode&lt;T&gt; insert(T t, BinaryNode&lt;T&gt; node) {
        if (node == null)
            return new BinaryNode&lt;&gt;(t, null, null);

        int compareResult = t.compareTo(node.element);

        if (compareResult &lt; 0)
            node.left = insert(t, node.left);
        else if (compareResult &gt; 0)
            node.right = insert(t, node.right);
        else
            /*我们先不考虑插入重复元素时的操作*/;

        return node;

    }

    private BinaryNode&lt;T&gt; remove(T t, BinaryNode&lt;T&gt; node) {
        if (node == null)
            return node;    //空树不做任何操作，直接返回。

        int compareResult = t.compareTo(node.element);

        if (compareResult &lt; 0) {
            node.left = remove(t, node.left);
        }else if (compareResult &gt; 0) {
            node.right = remove(t, node.right);
        }else if (node.left != null &amp;&amp; node.right != null){
            node.element = findMin(node.right).element;
            node.right = remove(node.element, node.right);
        }else
            node = (node.left != null) ? node.left : node.right;

        return node;
    }

    private void printTree(BinaryNode&lt;T&gt; node) {

    }
}

class Test02 {
    public static void main(String[] args) {
        BinarySearchTree&lt;Integer&gt; bst = new BinarySearchTree&lt;&gt;();
        bst.insert(5);
        bst.insert(3);
        bst.insert(7);
        bst.insert(1);
        bst.insert(4);
        bst.insert(6);
        bst.insert(8);
        bst.insert(9);

        bst.remove(4);

    }
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构学习——树（二）]]></title>
        <id>https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-shu-er/</id>
        <link href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-shu-er/">
        </link>
        <updated>2021-03-02T05:02:56.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>在计算机科学里，树的遍历（也称为树的搜索）是图的遍历的一种，指的是按照某种规则，不重复地访问某种树的所有节点的过程。具体的访问操作可能是检查节点的值、更新节点的值等。不同的遍历方式，其访问节点的顺序是不一样的。</li>
<li>先（根）序遍历：指的是尽可能先去访问根节点，直到该节点为叶子节点，然后对其左、右子树分别进行先序遍历的过程。（根-&gt;左-&gt;右）<br>
<img src="https://wylovecoding.github.io/post-images/1614662308407.png" alt="" loading="lazy"><br>
如图的节点访问顺序为：F-&gt;B-&gt;A-&gt;D-&gt;C-&gt;E-&gt;G-&gt;I-&gt;H</li>
<li>中（根）序遍历：指的是尽可能先去访问左子树，直到该节点为叶子节点，然后访问其根节点，最后对右子树进行中序遍历的过程。（左-&gt;根-&gt;右）<br>
<img src="https://wylovecoding.github.io/post-images/1614662831044.png" alt="" loading="lazy"><br>
如图的节点访问顺序为：A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;H-&gt;I</li>
<li>后（根）序遍历：指的是尽可能先去访问左子树，直到该节点为叶子节点，接着对右子树进行后序遍历，最后访问其根节点的过程。（左-&gt;右-&gt;根）<br>
<img src="https://wylovecoding.github.io/post-images/1614663344502.png" alt="" loading="lazy"><br>
如图的节点访问顺序为：A-&gt;C-&gt;E-&gt;D-&gt;B-&gt;H-&gt;I-&gt;G-&gt;F</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构学习——树（一）]]></title>
        <id>https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-shu-yi/</id>
        <link href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-shu-yi/">
        </link>
        <updated>2021-03-02T04:41:35.000Z</updated>
        <content type="html"><![CDATA[<p>💛1. 树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<pre><code>    ◾ 每个节点都只有有限个子节点或无子节点；
    ◾ 没有父节点的节点称为根节点；
    ◾ 每一个非根节点有且只有一个父节点；
    ◾ 除了根节点外，每个子节点可以分为多个不相交的子树；
    ◾ 树里面没有环路(cycle)
</code></pre>
<p><img src="https://wylovecoding.github.io/post-images/1614660213615.png" alt="" loading="lazy"><br>
💚2. 有关树的一些术语：</p>
<pre><code>        ◾ 节点的度：一个节点含有的子树的个数称为该节点的度；
        ◾ 树的度：一棵树中，最大的节点度称为树的度；
        ◾ 叶节点或终端节点：度为零的节点；
        ◾ 非终端节点或分支节点：度不为零的节点；
        ◾ 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；
        ◾  孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；
        ◾ 兄弟节点：具有相同父节点的节点互称为兄弟节点；
        ◾ 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
        ◾ 深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；
        ◾ 高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；
        ◾ 堂兄弟节点：父节点在同一层的节点互为堂兄弟；
        ◾ 节点的祖先：从根到该节点所经分支上的所有节点；
        ◾ 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。
        ◾ 森林：由m（m&gt;=0）棵互不相交的树的集合称为森林；
</code></pre>
<p>💙3. 树的种类：</p>
<pre><code>    ◾ 无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；
    ◾ 有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树； 　
    ◾ 二叉树：每个节点最多含有两个子树的树称为二叉树； 　　
    ◾ 完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树； 　　　
    ◾ 满二叉树：所有叶节点都在最底层的完全二叉树； 　　
    ◾ 平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树； 　　
    ◾ 排序二叉树(二叉查找树（英语：Binary Search Tree))：也称二叉搜索树、有序二叉树； 　
    ◾ 霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树； 　　
    ◾ B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。
</code></pre>
<p>💗4. 树的抽象：</p>
<table>
    <tr>
        <th>方法名</th>
        <th>描述</th>
    </tr>
    <tr>
        <td>getElement()</td>
        <td>返回存放于当前节点处的对象</td>
    </tr>
    <tr>
        <td>setElement(e)</td>
        <td>将对象 e 存入当前节点，并返回其中此前所存的内容</td>
    </tr>
    <tr>
        <td>getParent()</td>
        <td>返回当前节点的父节点</td>
    </tr>
    <tr>
        <td>getFirstChild()</td>
        <td>返回当前节点的长子</td>
    </tr>
    <tr>
        <td>getNextSibling()</td>
        <td>返回当前节点的最大弟弟</td>
    </tr>
</table>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构学习——队列]]></title>
        <id>https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-dui-lie-yi/</id>
        <link href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-dui-lie-yi/">
        </link>
        <updated>2021-03-01T06:06:57.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>同栈一样，队列（queue）也是表。然而使用队列时插入在一端进行删除在另一端进行。区别于栈的后进先出，队列是先进先出。</li>
<li>队列的基本操作有入队（enqueue），即在队尾（rear）插入一个元素；出队（dequeue），即删除队头（front）元素。</li>
<li>数组模拟实现队列。</li>
</ol>
<pre><code>class Test01{
    public static void main(String[] args) {
        QueueImpl&lt;Integer&gt; arr = new QueueImpl&lt;&gt;();
        arr.add(1);
        arr.add(2);
        arr.add(3);
        arr.add(4);
        arr.add(5);
        arr.add(6);
        System.out.println(arr.size()+&quot; &quot;+arr.isEmpty());
        while(!arr.isEmpty()){
            Integer temp = arr.remove();
            System.out.println(temp);
        }

    }
}

class QueueImpl&lt;T&gt; implements MyQueue&lt;T&gt;{
    private T[] data;
    private int size;
    private int front;
    private int rear;
    public QueueImpl() {
        data = (T[])new Object[3];
        size = 0;
        front = 0;
        rear = 0;
    }

    @Override
    public void add(T t) {
        if(isFull()){
            resize();
            front = 0;
        }
        rear = (front+size)%data.length;
        data[rear] = t;
        size++;
    }

    @Override
    public T remove() {
        if(isEmpty()){
            throw new RuntimeException(&quot;queue is empty!&quot;);
        }
        T tempData = data[front];
        data[front] = null;
        front = (front+1)%data.length;
        size--;
        return tempData;
    }

    @Override
    public int size() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public T front() {
        if(isEmpty()){
            throw new RuntimeException(&quot;queue is empty!&quot;);
        }
        return data[front];
    }

    public boolean isFull(){
        return size == data.length;
    }

    public void resize(){
        T[] tmp = (T[])new Object[data.length*2];
        System.arraycopy(data, 0, tmp, 0, data.length);
        data = tmp;
        tmp = null;
    }

}

interface MyQueue&lt;T&gt; {
    void add(T t);
    T remove();
    int size();
    boolean isEmpty();
    T front();
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构学习——栈（二）]]></title>
        <id>https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-zhan-er/</id>
        <link href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-zhan-er/">
        </link>
        <updated>2021-03-01T02:59:08.000Z</updated>
        <content type="html"><![CDATA[<p>使用栈实现数制转换</p>
<pre><code>/*
    使用栈来实现数制转换
 */
public class StackForNumberConversion {
    public static void numberConversion(int num, int numberSystem) {
        if (numberSystem &lt;= 0)
            System.out.println(&quot;The number to reserve must be bigger than zero !&quot;);

        Stack&lt;Integer&gt; s = new Stack&lt;&gt;();
        while (num &gt;= numberSystem){
            s.push(num % numberSystem);
            num = num / numberSystem;
        }
        s.push(num);

//        s.forEach(System.out::print);
        while (!s.isEmpty()) {
            System.out.print(s.pop());
        }



    }

    public static void main(String[] args) {
        numberConversion(12, 0);    
    }

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构学习——栈（一）]]></title>
        <id>https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-zhan-yi/</id>
        <link href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-zhan-yi/">
        </link>
        <updated>2021-03-01T02:17:28.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>栈（stack）是限制插入和删除只能在同一个位置（即栈顶）的表，有时也叫做后进先出（LIFO）表，对栈的基本操作有push进栈、pop出栈等。栈可以有两种实现方式分别是数组和链表，下面我们用链表来模拟栈的实现。</p>
</li>
<li>
<p>使用链表结构模拟栈的实现（Java语言）</p>
</li>
</ol>
<pre><code>/*
    栈的链表实现

 */
public class StackImpl_1&lt;T&gt; {
    private int size;   //栈的大小
    private Node head;  //栈顶元素

    /*
        栈的初始化
     */
    public StackImpl_1() {
        size = 0;
        head = null;
    }

    /**
     * 进栈操作
     * @param   t-即将进栈的元素
     */
        public void push(T t){
        Node newNode = new Node(t);
        if (size &gt; 0){
            newNode.next = head;
        }
        head = newNode;
        size ++;
    }

    /**
     * 出栈操作
     * @return 返回刚刚出栈的元素
     */
    public T pop(){
        if (size == 0)
            return null;
        else {
            Node deletedNode = head;
            head = head.next != null ? head.next : null;
            size --;
            return deletedNode.t;
        }
    }

    /**
     * top操作，获取栈顶元素
     * @return  返回栈顶元素
     */
    public T top(){
        return head != null ? head.t : null;
    }

    /**
     * 遍历栈
     * @param stack-
     */
    public void scanStack(StackImpl_1&lt;T&gt; stack){
        if (stack.size == 0)
            return;
        System.out.print(stack.pop() + &quot; &quot;);
        scanStack(stack);

    }

    private class Node{
        public T t;
        public Node next;

        public Node(T t) {
            this.t = t;
        }
    }

    public static void main(String[] args) {
        StackImpl_1&lt;String&gt; stack1 = new StackImpl_1&lt;&gt;();
        stack1.push(&quot;A&quot;);
        stack1.push(&quot;B&quot;);
        stack1.push(&quot;C&quot;);
        stack1.push(&quot;D&quot;);
        stack1.push(&quot;E&quot;);

        stack1.scanStack(stack1);
        System.out.println(stack1.top());

    }
}
</code></pre>
]]></content>
    </entry>
</feed>