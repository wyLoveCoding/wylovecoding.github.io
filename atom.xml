<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wylovecoding.github.io</id>
    <title>萌新求职记</title>
    <updated>2021-03-02T05:38:29.522Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wylovecoding.github.io"/>
    <link rel="self" href="https://wylovecoding.github.io/atom.xml"/>
    <subtitle>只要思想不滑坡，办法总比困难多</subtitle>
    <logo>https://wylovecoding.github.io/images/avatar.png</logo>
    <icon>https://wylovecoding.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 萌新求职记</rights>
    <entry>
        <title type="html"><![CDATA[数据结构学习——树（二）]]></title>
        <id>https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-shu-er/</id>
        <link href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-shu-er/">
        </link>
        <updated>2021-03-02T05:02:56.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>在计算机科学里，树的遍历（也称为树的搜索）是图的遍历的一种，指的是按照某种规则，不重复地访问某种树的所有节点的过程。具体的访问操作可能是检查节点的值、更新节点的值等。不同的遍历方式，其访问节点的顺序是不一样的。</li>
<li>先（根）序遍历：指的是尽可能先去访问根节点，直到该节点为叶子节点，然后对其左、右子树分别进行先序遍历的过程。（根-&gt;左-&gt;右）<br>
<img src="https://wylovecoding.github.io/post-images/1614662308407.png" alt="" loading="lazy"><br>
如图的节点访问顺序为：F-&gt;B-&gt;A-&gt;D-&gt;C-&gt;E-&gt;G-&gt;I-&gt;H</li>
<li>中（根）序遍历：指的是尽可能先去访问左子树，直到该节点为叶子节点，然后访问其根节点，最后对右子树进行中序遍历的过程。（左-&gt;根-&gt;右）<br>
<img src="https://wylovecoding.github.io/post-images/1614662831044.png" alt="" loading="lazy"><br>
如图的节点访问顺序为：A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;H-&gt;I</li>
<li>后（根）序遍历：指的是尽可能先去访问左子树，直到该节点为叶子节点，接着对右子树进行后序遍历，最后访问其根节点的过程。（左-&gt;右-&gt;根）<br>
<img src="https://wylovecoding.github.io/post-images/1614663344502.png" alt="" loading="lazy"><br>
如图的节点访问顺序为：A-&gt;C-&gt;E-&gt;D-&gt;B-&gt;H-&gt;I-&gt;G-&gt;F</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构学习——树（一）]]></title>
        <id>https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-shu-yi/</id>
        <link href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-shu-yi/">
        </link>
        <updated>2021-03-02T04:41:35.000Z</updated>
        <content type="html"><![CDATA[<p>💛1. 树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<pre><code>    ◾ 每个节点都只有有限个子节点或无子节点；
    ◾ 没有父节点的节点称为根节点；
    ◾ 每一个非根节点有且只有一个父节点；
    ◾ 除了根节点外，每个子节点可以分为多个不相交的子树；
    ◾ 树里面没有环路(cycle)
</code></pre>
<p><img src="https://wylovecoding.github.io/post-images/1614660213615.png" alt="" loading="lazy"><br>
💚2. 有关树的一些术语：</p>
<pre><code>        ◾ 节点的度：一个节点含有的子树的个数称为该节点的度；
        ◾ 树的度：一棵树中，最大的节点度称为树的度；
        ◾ 叶节点或终端节点：度为零的节点；
        ◾ 非终端节点或分支节点：度不为零的节点；
        ◾ 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；
        ◾  孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；
        ◾ 兄弟节点：具有相同父节点的节点互称为兄弟节点；
        ◾ 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
        ◾ 深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；
        ◾ 高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；
        ◾ 堂兄弟节点：父节点在同一层的节点互为堂兄弟；
        ◾ 节点的祖先：从根到该节点所经分支上的所有节点；
        ◾ 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。
        ◾ 森林：由m（m&gt;=0）棵互不相交的树的集合称为森林；
</code></pre>
<p>💙3. 树的种类：</p>
<pre><code>    ◾ 无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；
    ◾ 有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树； 　
    ◾ 二叉树：每个节点最多含有两个子树的树称为二叉树； 　　
    ◾ 完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树； 　　　
    ◾ 满二叉树：所有叶节点都在最底层的完全二叉树； 　　
    ◾ 平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树； 　　
    ◾ 排序二叉树(二叉查找树（英语：Binary Search Tree))：也称二叉搜索树、有序二叉树； 　
    ◾ 霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树； 　　
    ◾ B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。
</code></pre>
<p>💗4. 树的抽象：</p>
<table>
    <tr>
        <th>方法名</th>
        <th>描述</th>
    </tr>
    <tr>
        <td>getElement()</td>
        <td>返回存放于当前节点处的对象</td>
    </tr>
    <tr>
        <td>setElement(e)</td>
        <td>将对象 e 存入当前节点，并返回其中此前所存的内容</td>
    </tr>
    <tr>
        <td>getParent()</td>
        <td>返回当前节点的父节点</td>
    </tr>
    <tr>
        <td>getFirstChild()</td>
        <td>返回当前节点的长子</td>
    </tr>
    <tr>
        <td>getNextSibling()</td>
        <td>返回当前节点的最大弟弟</td>
    </tr>
</table>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构学习——队列]]></title>
        <id>https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-dui-lie-yi/</id>
        <link href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-dui-lie-yi/">
        </link>
        <updated>2021-03-01T06:06:57.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>同栈一样，队列（queue）也是表。然而使用队列时插入在一端进行删除在另一端进行。区别于栈的后进先出，队列是先进先出。</li>
<li>队列的基本操作有入队（enqueue），即在队尾（rear）插入一个元素；出队（dequeue），即删除队头（front）元素。</li>
<li>数组模拟实现队列。</li>
</ol>
<pre><code>class Test01{
    public static void main(String[] args) {
        QueueImpl&lt;Integer&gt; arr = new QueueImpl&lt;&gt;();
        arr.add(1);
        arr.add(2);
        arr.add(3);
        arr.add(4);
        arr.add(5);
        arr.add(6);
        System.out.println(arr.size()+&quot; &quot;+arr.isEmpty());
        while(!arr.isEmpty()){
            Integer temp = arr.remove();
            System.out.println(temp);
        }

    }
}

class QueueImpl&lt;T&gt; implements MyQueue&lt;T&gt;{
    private T[] data;
    private int size;
    private int front;
    private int rear;
    public QueueImpl() {
        data = (T[])new Object[3];
        size = 0;
        front = 0;
        rear = 0;
    }

    @Override
    public void add(T t) {
        if(isFull()){
            resize();
            front = 0;
        }
        rear = (front+size)%data.length;
        data[rear] = t;
        size++;
    }

    @Override
    public T remove() {
        if(isEmpty()){
            throw new RuntimeException(&quot;queue is empty!&quot;);
        }
        T tempData = data[front];
        data[front] = null;
        front = (front+1)%data.length;
        size--;
        return tempData;
    }

    @Override
    public int size() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public T front() {
        if(isEmpty()){
            throw new RuntimeException(&quot;queue is empty!&quot;);
        }
        return data[front];
    }

    public boolean isFull(){
        return size == data.length;
    }

    public void resize(){
        T[] tmp = (T[])new Object[data.length*2];
        System.arraycopy(data, 0, tmp, 0, data.length);
        data = tmp;
        tmp = null;
    }

}

interface MyQueue&lt;T&gt; {
    void add(T t);
    T remove();
    int size();
    boolean isEmpty();
    T front();
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构学习——栈（二）]]></title>
        <id>https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-zhan-er/</id>
        <link href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-zhan-er/">
        </link>
        <updated>2021-03-01T02:59:08.000Z</updated>
        <content type="html"><![CDATA[<p>使用栈实现数制转换</p>
<pre><code>/*
    使用栈来实现数制转换
 */
public class StackForNumberConversion {
    public static void numberConversion(int num, int numberSystem) {
        if (numberSystem &lt;= 0)
            System.out.println(&quot;The number to reserve must be bigger than zero !&quot;);

        Stack&lt;Integer&gt; s = new Stack&lt;&gt;();
        while (num &gt;= numberSystem){
            s.push(num % numberSystem);
            num = num / numberSystem;
        }
        s.push(num);

//        s.forEach(System.out::print);
        while (!s.isEmpty()) {
            System.out.print(s.pop());
        }



    }

    public static void main(String[] args) {
        numberConversion(12, 0);    
    }

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构学习——栈（一）]]></title>
        <id>https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-zhan-yi/</id>
        <link href="https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-zhan-yi/">
        </link>
        <updated>2021-03-01T02:17:28.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>栈（stack）是限制插入和删除只能在同一个位置（即栈顶）的表，有时也叫做后进先出（LIFO）表，对栈的基本操作有push进栈、pop出栈等。栈可以有两种实现方式分别是数组和链表，下面我们用链表来模拟栈的实现。</p>
</li>
<li>
<p>使用链表结构模拟栈的实现（Java语言）</p>
</li>
</ol>
<pre><code>/*
    栈的链表实现

 */
public class StackImpl_1&lt;T&gt; {
    private int size;   //栈的大小
    private Node head;  //栈顶元素

    /*
        栈的初始化
     */
    public StackImpl_1() {
        size = 0;
        head = null;
    }

    /**
     * 进栈操作
     * @param   t-即将进栈的元素
     */
        public void push(T t){
        Node newNode = new Node(t);
        if (size &gt; 0){
            newNode.next = head;
        }
        head = newNode;
        size ++;
    }

    /**
     * 出栈操作
     * @return 返回刚刚出栈的元素
     */
    public T pop(){
        if (size == 0)
            return null;
        else {
            Node deletedNode = head;
            head = head.next != null ? head.next : null;
            size --;
            return deletedNode.t;
        }
    }

    /**
     * top操作，获取栈顶元素
     * @return  返回栈顶元素
     */
    public T top(){
        return head != null ? head.t : null;
    }

    /**
     * 遍历栈
     * @param stack-
     */
    public void scanStack(StackImpl_1&lt;T&gt; stack){
        if (stack.size == 0)
            return;
        System.out.print(stack.pop() + &quot; &quot;);
        scanStack(stack);

    }

    private class Node{
        public T t;
        public Node next;

        public Node(T t) {
            this.t = t;
        }
    }

    public static void main(String[] args) {
        StackImpl_1&lt;String&gt; stack1 = new StackImpl_1&lt;&gt;();
        stack1.push(&quot;A&quot;);
        stack1.push(&quot;B&quot;);
        stack1.push(&quot;C&quot;);
        stack1.push(&quot;D&quot;);
        stack1.push(&quot;E&quot;);

        stack1.scanStack(stack1);
        System.out.println(stack1.top());

    }
}
</code></pre>
]]></content>
    </entry>
</feed>