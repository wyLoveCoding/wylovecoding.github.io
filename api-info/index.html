{"posts":[{"fileName":"java-duo-xian-cheng-xue-xi-zong-jie","abstract":"","description":"1.1 进程与线程 1.1.1 进程 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即 是一个进程从创建、运行到消亡的过程。在Java中，当我们启动main函数，其实就是启动了一个JVM的进程，而m...","title":"Java多线程学习总结","tags":[],"feature":"","link":"https://wylovecoding.github.io/post/java-duo-xian-cheng-xue-xi-zong-jie/","stats":{"text":"19 min read","time":1086000,"words":4947,"minutes":19},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#11-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B\">1.1 进程与线程</a>\n<ul>\n<li><a href=\"#111-%E8%BF%9B%E7%A8%8B\">1.1.1 进程</a></li>\n<li><a href=\"#112-%E7%BA%BF%E7%A8%8B\">1.1.2 线程</a></li>\n<li><a href=\"#113-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB-%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9\">1.1.3 进程与线程之间的关系、区别及优缺点</a></li>\n</ul>\n</li>\n<li><a href=\"#12-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C\">1.2 并发与并行</a></li>\n<li><a href=\"#13-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B\">1.3 为什么要使用多线程</a></li>\n<li><a href=\"#14-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%83%BD%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\">1.4 使用多线程可能带来什么问题</a></li>\n<li><a href=\"#15-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81\">1.5 线程的生命周期和状态</a></li>\n<li><a href=\"#16-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2\">1.6 上下文切换</a></li>\n<li><a href=\"#17-%E6%AD%BB%E9%94%81\">1.7 死锁</a>\n<ul>\n<li><a href=\"#171-%E8%AE%A4%E8%AF%86%E6%AD%BB%E9%94%81\">1.7.1 认识死锁</a></li>\n<li><a href=\"#172-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81\">1.7.2 避免死锁</a></li>\n</ul>\n</li>\n<li><a href=\"#18-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%B0%83%E7%94%A8start%E6%96%B9%E6%B3%95%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8Crun%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8run%E6%96%B9%E6%B3%95\">1.8 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法</a></li>\n<li><a href=\"#19-sleep%E6%96%B9%E6%B3%95%E5%92%8Cwait%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%85%B1%E5%90%8C%E7%82%B9\">1.9 sleep()方法和wait()方法的区别与共同点</a></li>\n<li><a href=\"#110-synchronized%E5%85%B3%E9%94%AE%E5%AD%97\">1.10 Synchronized关键字</a>\n<ul>\n<li><a href=\"#1101-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BD%A2%E5%BC%8F\">1.10.1 synchronized关键字几种常见的使用形式</a></li>\n<li><a href=\"#1102-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%94%E7%94%A8%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\">1.10.2 synchronized关键字的应用——双重检验锁实现单例模式</a></li>\n</ul>\n</li>\n<li><a href=\"#111-cpu%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98\">1.11 CPU高速缓存</a>\n<ul>\n<li><a href=\"#1111-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89cpu-cache\">1.11.1 为什么会有cpu cache</a></li>\n<li><a href=\"#1112-cpu-cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F\">1.11.2 cpu cache的工作方式</a></li>\n</ul>\n</li>\n<li><a href=\"#112-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB\">1.12 Synchronized关键字和volatile关键字的区别</a></li>\n<li><a href=\"#113-%E7%BA%BF%E7%A8%8B%E6%B1%A0\">1.13 线程池</a>\n<ul>\n<li><a href=\"#1131-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0\">1.13.1 为什么使用线程池</a></li>\n<li><a href=\"#1132-%E5%AE%9E%E7%8E%B0runnable%E6%8E%A5%E5%8F%A3%E5%92%8Ccallable%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB\">1.13.2 实现Runnable接口和Callable接口的区别</a></li>\n<li><a href=\"#1133-%E6%89%A7%E8%A1%8Cexecute%E6%96%B9%E6%B3%95%E5%92%8Csubmit%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB\">1.13.3 执行execute()方法和submit()方法的区别</a></li>\n<li><a href=\"#1134-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0\">1.13.4 创建线程池</a></li>\n<li><a href=\"#1135-threadpoolexecutor%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90\">1.13.5 ThreadPoolExecutor类构造方法重要参数解析</a></li>\n<li><a href=\"#1136-threadpoolexecutor%E7%9A%84%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5\">1.13.6 ThreadPoolExecutor的饱和策略</a></li>\n</ul>\n</li>\n<li><a href=\"#114-atomic%E5%8E%9F%E5%AD%90%E7%B1%BB\">1.14 Atomic原子类</a>\n<ul>\n<li><a href=\"#1141-javautilconcurrent%E5%8C%85%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB\">1.14.1 java.util.concurrent包中的原子类</a></li>\n</ul>\n</li>\n<li><a href=\"#115-countdownlatch\">1.15 CountDownLatch</a></li>\n</ul>\n</li>\n</ul>\n","date":"2021-04-06 18:55:39","dateFormat":"2021-04-06"},{"fileName":"jing-dian-kuai-su-pai-xu-suan-fa-java-shi-xian","abstract":"","description":"代码参考自《数据结构与算法分析Java语言描述》一书。 public class QuickSort { public static void main(String[] args) { Integer[] arr...","title":"经典快速排序算法Java实现","tags":[{"index":-1,"name":"算法学习","slug":"q70utjvai","used":true,"link":"https://wylovecoding.github.io/tag/q70utjvai/"},{"index":-1,"name":"Java","slug":"ov8AxLVRR","used":true,"link":"https://wylovecoding.github.io/tag/ov8AxLVRR/"},{"index":-1,"name":"数据结构学习","slug":"Cy8dFWKpa","used":true,"link":"https://wylovecoding.github.io/tag/Cy8dFWKpa/"}],"feature":"","link":"https://wylovecoding.github.io/post/jing-dian-kuai-su-pai-xu-suan-fa-java-shi-xian/","stats":{"text":"3 min read","time":127000,"words":367,"minutes":3},"isTop":false,"toc":"","date":"2021-03-10 10:18:28","dateFormat":"2021-03-10"},{"fileName":"pai-xu-dui-pai-xu","abstract":"","description":"堆排序的Java代码实现。 public class HeapSort { public static void main(String[] args) { Integer[] arr = {5, 7, 4, 6, ...","title":"排序——堆排序","tags":[{"index":-1,"name":"算法学习","slug":"q70utjvai","used":true,"link":"https://wylovecoding.github.io/tag/q70utjvai/"},{"index":-1,"name":"Java","slug":"ov8AxLVRR","used":true,"link":"https://wylovecoding.github.io/tag/ov8AxLVRR/"},{"index":-1,"name":"数据结构学习","slug":"Cy8dFWKpa","used":true,"link":"https://wylovecoding.github.io/tag/Cy8dFWKpa/"}],"feature":"","link":"https://wylovecoding.github.io/post/pai-xu-dui-pai-xu/","stats":{"text":"3 min read","time":139000,"words":493,"minutes":3},"isTop":false,"toc":"","date":"2021-03-07 21:00:08","dateFormat":"2021-03-07"},{"fileName":"shu-ju-jie-gou-xue-xi-er-cha-sou-suo-pai-xu-shu-de-shi-xian","abstract":"","description":"下面将使用Java语言分别实现二叉搜索树的 判空、置空、 插入、 删除、 包含等操作。 /* 二叉查找树的实现 */ public class BinarySearchTree &lt;T extends Comparable&lt...","title":"数据结构学习——二叉搜索（排序）树的实现","tags":[{"index":-1,"name":"Java","slug":"ov8AxLVRR","used":true,"link":"https://wylovecoding.github.io/tag/ov8AxLVRR/"},{"index":-1,"name":"数据结构学习","slug":"Cy8dFWKpa","used":true,"link":"https://wylovecoding.github.io/tag/Cy8dFWKpa/"}],"feature":"","link":"https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-er-cha-sou-suo-pai-xu-shu-de-shi-xian/","stats":{"text":"4 min read","time":225000,"words":733,"minutes":4},"isTop":false,"toc":"","date":"2021-03-03 13:52:48","dateFormat":"2021-03-03"},{"fileName":"shu-ju-jie-gou-xue-xi-shu-er","abstract":"","description":" 在计算机科学里，树的遍历（也称为树的搜索）是图的遍历的一种，指的是按照某种规则，不重复地访问某种树的所有节点的过程。具体的访问操作可能是检查节点的值、更新节点的值等。不同的遍历方式，其访问节点的顺序是不一样的。 先（根）序遍历：指的是尽可...","title":"数据结构学习——树（二）","tags":[{"index":-1,"name":"Java","slug":"ov8AxLVRR","used":true,"link":"https://wylovecoding.github.io/tag/ov8AxLVRR/"},{"index":-1,"name":"数据结构学习","slug":"Cy8dFWKpa","used":true,"link":"https://wylovecoding.github.io/tag/Cy8dFWKpa/"}],"feature":"","link":"https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-shu-er/","stats":{"text":"2 min read","time":77000,"words":340,"minutes":2},"isTop":false,"toc":"","date":"2021-03-02 13:02:56","dateFormat":"2021-03-02"},{"fileName":"shu-ju-jie-gou-xue-xi-shu-yi","abstract":"","description":"💛1. 树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就...","title":"数据结构学习——树（一）","tags":[{"index":-1,"name":"Java","slug":"ov8AxLVRR","used":true,"link":"https://wylovecoding.github.io/tag/ov8AxLVRR/"},{"index":-1,"name":"数据结构学习","slug":"Cy8dFWKpa","used":true,"link":"https://wylovecoding.github.io/tag/Cy8dFWKpa/"}],"feature":"","link":"https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-shu-yi/","stats":{"text":"4 min read","time":193000,"words":930,"minutes":4},"isTop":false,"toc":"","date":"2021-03-02 12:41:35","dateFormat":"2021-03-02"},{"fileName":"shu-ju-jie-gou-xue-xi-dui-lie-yi","abstract":"","description":" 同栈一样，队列（queue）也是表。然而使用队列时插入在一端进行删除在另一端进行。区别于栈的后进先出，队列是先进先出。 队列的基本操作有入队（enqueue），即在队尾（rear）插入一个元素；出队（dequeue），即删除队头（fron...","title":"数据结构学习——队列","tags":[{"index":-1,"name":"Java","slug":"ov8AxLVRR","used":true,"link":"https://wylovecoding.github.io/tag/ov8AxLVRR/"},{"index":-1,"name":"数据结构学习","slug":"Cy8dFWKpa","used":true,"link":"https://wylovecoding.github.io/tag/Cy8dFWKpa/"}],"feature":"","link":"https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-dui-lie-yi/","stats":{"text":"2 min read","time":99000,"words":305,"minutes":2},"isTop":false,"toc":"","date":"2021-03-01 14:06:57","dateFormat":"2021-03-01"},{"fileName":"shu-ju-jie-gou-xue-xi-zhan-er","abstract":"","description":"使用栈实现数制转换 /* 使用栈来实现数制转换 */ public class StackForNumberConversion { public static void numberConversion(int num,...","title":"数据结构学习——栈（二）","tags":[{"index":-1,"name":"Java","slug":"ov8AxLVRR","used":true,"link":"https://wylovecoding.github.io/tag/ov8AxLVRR/"},{"index":-1,"name":"数据结构学习","slug":"Cy8dFWKpa","used":true,"link":"https://wylovecoding.github.io/tag/Cy8dFWKpa/"}],"feature":"","link":"https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-zhan-er/","stats":{"text":"1 min read","time":31000,"words":93,"minutes":1},"isTop":false,"toc":"","date":"2021-03-01 10:59:08","dateFormat":"2021-03-01"},{"fileName":"shu-ju-jie-gou-xue-xi-zhan-yi","abstract":"","description":" 栈（stack）是限制插入和删除只能在同一个位置（即栈顶）的表，有时也叫做后进先出（LIFO）表，对栈的基本操作有push进栈、pop出栈等。栈可以有两种实现方式分别是数组和链表，下面我们用链表来模拟栈的实现。 使用链表结构模拟栈的...","title":"数据结构学习——栈（一）","tags":[{"index":-1,"name":"Java","slug":"ov8AxLVRR","used":true,"link":"https://wylovecoding.github.io/tag/ov8AxLVRR/"},{"index":-1,"name":"数据结构学习","slug":"Cy8dFWKpa","used":true,"link":"https://wylovecoding.github.io/tag/Cy8dFWKpa/"}],"feature":"","link":"https://wylovecoding.github.io/post/shu-ju-jie-gou-xue-xi-zhan-yi/","stats":{"text":"2 min read","time":93000,"words":319,"minutes":2},"isTop":false,"toc":"","date":"2021-03-01 10:17:28","dateFormat":"2021-03-01"}],"tags":[{"index":-1,"name":"算法学习","slug":"q70utjvai","used":true,"link":"https://wylovecoding.github.io/tag/q70utjvai/","count":2},{"index":-1,"name":"Java","slug":"ov8AxLVRR","used":true,"link":"https://wylovecoding.github.io/tag/ov8AxLVRR/","count":8},{"index":-1,"name":"数据结构学习","slug":"Cy8dFWKpa","used":true,"link":"https://wylovecoding.github.io/tag/Cy8dFWKpa/","count":8}],"menus":[{"link":"/","name":"首页","openType":"Internal"},{"link":"/archives","name":"归档","openType":"Internal"},{"link":"/tags","name":"标签","openType":"Internal"},{"link":"/post/about","name":"关于","openType":"Internal"}],"themeConfig":{"themeName":"pure","postPageSize":10,"archivesPageSize":50,"siteName":"我爱刷题","siteDescription":"心中无女人，编码自然神(●'◡'●)","footerInfo":"Powered by <a href=\"https://github.com/getgridea/gridea\" target=\"_blank\">Gridea</a>","showFeatureImage":true,"domain":"https://wylovecoding.github.io","postUrlFormat":"SLUG","tagUrlFormat":"SHORT_ID","dateFormat":"YYYY-MM-DD","feedFullText":true,"feedCount":10,"archivesPath":"archives","postPath":"post","tagPath":"tag"},"customConfig":{"APP_ID":"","APP_KEY":"","about":"","avatar":"","caf":"#84fab0","ccf":"#5f6169","ccs":"#999fa7","ctf":"#ffffff","cts":"#dddddd","customCss":"","descfriend":"","dribbble":"","facebook":"","friends":[],"ga":"","github":"https://github.com/wyLoveCoding","isEnabledCustomColor":false,"pageSize":"5","placeholder":"Just Go Go","recordIp":true,"skin":"green","twitter":"","vMaxWidth":"1000","vPadding":"2.5%","vPercentWidth":"100","valine":false,"visitor":true,"weibo":"","zhihu":""},"utils":{"now":1617874742542}}
